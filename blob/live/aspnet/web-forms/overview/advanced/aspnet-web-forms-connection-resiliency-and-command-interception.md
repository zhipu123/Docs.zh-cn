---
uid: web-forms/overview/advanced/aspnet-web-forms-connection-resiliency-and-command-interception
title: "ASP.NET Web 窗体连接复原和命令截获 |Microsoft 文档"
author: Erikre
description: "本教程介绍如何修改示例应用程序以支持连接复原和命令截获。"
ms.author: aspnetcontent
manager: wpickett
ms.date: 03/31/2014
ms.topic: article
ms.assetid: 6d497001-fa80-4765-b4cc-181fe90b894e
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/advanced/aspnet-web-forms-connection-resiliency-and-command-interception
msc.type: authoredcontent
ms.openlocfilehash: 1c24ccd220bf6df09a958d07b13077f004da0a03
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/10/2017
---
<a name="aspnet-web-forms-connection-resiliency-and-command-interception"></a><span data-ttu-id="ea6ae-103">ASP.NET Web 窗体连接复原和命令截获</span><span class="sxs-lookup"><span data-stu-id="ea6ae-103">ASP.NET Web Forms Connection Resiliency and Command Interception</span></span>
====================
<span data-ttu-id="ea6ae-104">通过[艾力克 Reitan](https://github.com/Erikre)</span><span class="sxs-lookup"><span data-stu-id="ea6ae-104">by [Erik Reitan](https://github.com/Erikre)</span></span>

<span data-ttu-id="ea6ae-105">在本教程中，你将要修改 Wingtip Toys 示例应用程序以支持连接复原和命令截获。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-105">In this tutorial, you will modify the Wingtip Toys sample application to support connection resiliency and command interception.</span></span> <span data-ttu-id="ea6ae-106">通过启用连接复原，Wingtip Toys 示例应用程序将自动重试数据调用云环境的典型的暂时性错误发生时。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-106">By enabling connection resiliency, the Wingtip Toys sample application will automatically retry data calls when transient errors typical of a cloud environment occur.</span></span> <span data-ttu-id="ea6ae-107">此外，通过实现命令截获，Wingtip Toys 示例应用程序将捕捉所有发送到若要登录，或更改这些数据库的 SQL 查询。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-107">Also, by implementing command interception, the Wingtip Toys sample application will catch all SQL queries sent to the database in order to log or change them.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="ea6ae-108">此 Web 窗体教程基于 Tom Dykstra 的以下 MVC 教程：</span><span class="sxs-lookup"><span data-stu-id="ea6ae-108">This Web Forms tutorial was based on Tom Dykstra's following MVC tutorial:</span></span>  
> [<span data-ttu-id="ea6ae-109">连接复原和命令截获与实体框架中的 ASP.NET MVC 应用程序</span><span class="sxs-lookup"><span data-stu-id="ea6ae-109">Connection Resiliency and Command Interception with the Entity Framework in an ASP.NET MVC Application</span></span>](../../../mvc/overview/getting-started/getting-started-with-ef-using-mvc/connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application.md)


## <a name="what-youll-learn"></a><span data-ttu-id="ea6ae-110">你将学习：</span><span class="sxs-lookup"><span data-stu-id="ea6ae-110">What you'll learn:</span></span>

- <span data-ttu-id="ea6ae-111">如何提供连接复原能力。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-111">How to provide connection resiliency.</span></span>
- <span data-ttu-id="ea6ae-112">如何实现命令截获。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-112">How to implement command interception.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="ea6ae-113">先决条件</span><span class="sxs-lookup"><span data-stu-id="ea6ae-113">Prerequisites</span></span>

<span data-ttu-id="ea6ae-114">在开始之前，请确保你已在计算机上安装以下软件：</span><span class="sxs-lookup"><span data-stu-id="ea6ae-114">Before you start, make sure that you have the following software installed on your computer:</span></span>

- <span data-ttu-id="ea6ae-115">[Microsoft Visual Studio 2013](https://www.microsoft.com/visualstudio/11/en-us/downloads#vs)或[Microsoft Visual Studio Express 2013 for Web](https://www.microsoft.com/visualstudio/11/en-us/downloads#express-web)。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-115">[Microsoft Visual Studio 2013](https://www.microsoft.com/visualstudio/11/en-us/downloads#vs) or [Microsoft Visual Studio Express 2013 for Web](https://www.microsoft.com/visualstudio/11/en-us/downloads#express-web).</span></span> <span data-ttu-id="ea6ae-116">自动安装.NET Framework。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-116">The .NET Framework is installed automatically.</span></span>
- <span data-ttu-id="ea6ae-117">Wingtip Toys 示例项目，以便你可以实现在本教程中 Wingtip Toys 项目中所述的功能。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-117">The Wingtip Toys sample project, so that you can implement the functionality mentioned in this tutorial within the Wingtip Toys project.</span></span> <span data-ttu-id="ea6ae-118">以下链接提供下载详细信息：</span><span class="sxs-lookup"><span data-stu-id="ea6ae-118">The following link provides download details:</span></span>

    - <span data-ttu-id="ea6ae-119">[Getting Started with ASP.NET 4.5.1 Web 窗体的 Wingtip Toys](https://go.microsoft.com/fwlink/?LinkID=389434&amp;clcid=0x409) (C#)</span><span class="sxs-lookup"><span data-stu-id="ea6ae-119">[Getting Started with ASP.NET 4.5.1 Web Forms - Wingtip Toys](https://go.microsoft.com/fwlink/?LinkID=389434&amp;clcid=0x409) (C#)</span></span>
- <span data-ttu-id="ea6ae-120">之前完成本教程，请考虑查看相关的教程系列， [Getting Started with ASP.NET 4.5 Web 窗体和 Visual Studio 2013](../getting-started/getting-started-with-aspnet-45-web-forms/introduction-and-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-120">Prior to completing this tutorial, consider reviewing the related tutorial series, [Getting Started with ASP.NET 4.5 Web Forms and Visual Studio 2013](../getting-started/getting-started-with-aspnet-45-web-forms/introduction-and-overview.md).</span></span> <span data-ttu-id="ea6ae-121">系列教程将帮助你熟悉**WingtipToys**项目和代码。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-121">The tutorial series will help you become familiar with the **WingtipToys** project and code.</span></span>

## <a name="connection-resiliency"></a><span data-ttu-id="ea6ae-122">连接复原</span><span class="sxs-lookup"><span data-stu-id="ea6ae-122">Connection resiliency</span></span>

<span data-ttu-id="ea6ae-123">当你考虑应用程序部署到 Windows Azure 时，可考虑使用一个选项部署到数据库**Windows** **Azure SQL 数据库**，云数据库服务。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-123">When you consider deploying an application to Windows Azure, one option to consider is deploying the database to **Windows** **Azure SQL Database**, a cloud database service.</span></span> <span data-ttu-id="ea6ae-124">连接到云数据库服务时与你的 web 服务器和数据库服务器直接连接在一起位于同一数据中心时，暂时性连接错误是通常更频繁。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-124">Transient connection errors are typically more frequent when you connect to a cloud database service than when your web server and your database server are directly connected together in the same data center.</span></span> <span data-ttu-id="ea6ae-125">即使在同一数据中心中承载的云 web 服务器和云数据库服务时，有更多的网络连接，它们将会出现问题，例如负载平衡器之间。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-125">Even if a cloud web server and a cloud database service are hosted in the same data center, there are more network connections between them that can have problems, such as load balancers.</span></span>

<span data-ttu-id="ea6ae-126">此外云服务通常由其他用户共享，这意味着其响应能力可能受到它们。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-126">Also a cloud service is typically shared by other users, which means its responsiveness can be affected by them.</span></span> <span data-ttu-id="ea6ae-127">并且您对数据库访问权限可能受到限制。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-127">And your access to the database might be subject to throttling.</span></span> <span data-ttu-id="ea6ae-128">限制意味着数据库服务会引发异常，当你尝试超出允许的更频繁地访问你*服务级别协议*(SLA)。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-128">Throttling means the database service throws exceptions when you try to access it more frequently than is allowed in your *Service Level Agreement* (SLA).</span></span>

<span data-ttu-id="ea6ae-129">许多或大多数发生时你正在访问云服务的连接问题是暂时的也就是说，它们自身解决在短时间的时间。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-129">Many or most connection problems that occur when you're accessing a cloud service are transient, that is, they resolve themselves in a short period of time.</span></span> <span data-ttu-id="ea6ae-130">因此当你尝试数据库操作，并获取一种是通常暂时性的错误，稍等片刻，该操作可能会成功后无法重试该操作。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-130">So when you try a database operation and get a type of error that is typically transient, you could try the operation again after a short wait, and the operation might be successful.</span></span> <span data-ttu-id="ea6ae-131">如果通过自动重试，处理暂时性错误，可以为你的用户提供更好的体验使其中的大多数客户不可见。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-131">You can provide a much better experience for your users if you handle transient errors by automatically trying again, making most of them invisible to the customer.</span></span> <span data-ttu-id="ea6ae-132">连接复原功能 Entity Framework 6 中的自动执行过程的重试失败的 SQL 查询。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-132">The connection resiliency feature in Entity Framework 6 automates that process of retrying failed SQL queries.</span></span>

<span data-ttu-id="ea6ae-133">针对特定数据库服务，必须适当地配置连接复原功能：</span><span class="sxs-lookup"><span data-stu-id="ea6ae-133">The connection resiliency feature must be configured appropriately for a particular database service:</span></span>

1. <span data-ttu-id="ea6ae-134">它必须知道哪些异常很可能是暂时的。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-134">It has to know which exceptions are likely to be transient.</span></span> <span data-ttu-id="ea6ae-135">你想要重试错误导致通过暂时丢失网络连接，不由程序 bug，例如引起的错误。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-135">You want to retry errors caused by a temporary loss in network connectivity, not errors caused by program bugs, for example.</span></span>
2. <span data-ttu-id="ea6ae-136">它必须等待适当的失败的操作的重试之间的时间量。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-136">It has to wait an appropriate amount of time between retries of a failed operation.</span></span> <span data-ttu-id="ea6ae-137">你可以等待，再进行批处理的重试之间不是用户正在等待响应的联机 web 页可以。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-137">You can wait longer between retries for a batch process than you can for an online web page where a user is waiting for a response.</span></span>
3. <span data-ttu-id="ea6ae-138">它具有重试之前的适当次数。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-138">It has to retry an appropriate number of times before it gives up.</span></span> <span data-ttu-id="ea6ae-139">你可能想要重试更多次，就像在联机应用程序中的批处理中。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-139">You might want to retry more times in a batch process that you would in an online application.</span></span>

<span data-ttu-id="ea6ae-140">可以配置为支持的实体框架提供程序的任何数据库环境手动这些设置。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-140">You can configure these settings manually for any database environment supported by an Entity Framework provider.</span></span>

<span data-ttu-id="ea6ae-141">你所要做，以启用连接复原的就是中派生自程序集创建一个类`DbConfiguration`类和在该类中设置 SQL 数据库执行策略，即实体框架中的重试策略另一个术语。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-141">All you have to do to enable connection resiliency is create a class in your assembly that derives from the `DbConfiguration` class, and in that class set the SQL Database execution strategy, which in Entity Framework is another term for retry policy.</span></span>

### <a name="implementing-connection-resiliency"></a><span data-ttu-id="ea6ae-142">实现连接复原</span><span class="sxs-lookup"><span data-stu-id="ea6ae-142">Implementing connection resiliency</span></span>

1. <span data-ttu-id="ea6ae-143">下载并打开[WingtipToys](https://go.microsoft.com/fwlink/?LinkID=389434&amp;clcid=0x409)示例 Visual Studio 中的 Web 窗体应用程序。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-143">Download and open the [WingtipToys](https://go.microsoft.com/fwlink/?LinkID=389434&amp;clcid=0x409) sample Web Forms application in Visual Studio.</span></span>
2. <span data-ttu-id="ea6ae-144">在*逻辑*文件夹**WingtipToys**应用程序中，添加一个名为的类文件*WingtipToysConfiguration.cs*。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-144">In the *Logic* folder of the **WingtipToys** application, add a class file named *WingtipToysConfiguration.cs*.</span></span>
3. <span data-ttu-id="ea6ae-145">用下面的代码替换现有代码：</span><span class="sxs-lookup"><span data-stu-id="ea6ae-145">Replace the existing code with the following code:</span></span>  

    [!code-csharp[Main](aspnet-web-forms-connection-resiliency-and-command-interception/samples/sample1.cs)]

<span data-ttu-id="ea6ae-146">实体框架将自动运行它派生自的类中找到的代码`DbConfiguration`。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-146">The Entity Framework automatically runs the code it finds in a class that derives from `DbConfiguration`.</span></span> <span data-ttu-id="ea6ae-147">你可以使用`DbConfiguration`类来执行此在中否则所执行的操作的代码中的配置任务*Web.config*文件。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-147">You can use the `DbConfiguration` class to do configuration tasks in code that you would otherwise do in the *Web.config* file.</span></span> <span data-ttu-id="ea6ae-148">有关详细信息，请参阅[EntityFramework 基于代码的配置](https://msdn.microsoft.com/data/jj680699)。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-148">For more information, see [EntityFramework Code-Based Configuration](https://msdn.microsoft.com/data/jj680699).</span></span>

1. <span data-ttu-id="ea6ae-149">在*逻辑*文件夹中，打开*AddProducts.cs*文件。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-149">In the *Logic* folder, open the *AddProducts.cs* file.</span></span>
2. <span data-ttu-id="ea6ae-150">添加`using`语句`System.Data.Entity.Infrastructure`如所示以黄色突出显示：</span><span class="sxs-lookup"><span data-stu-id="ea6ae-150">Add a `using` statement for `System.Data.Entity.Infrastructure` as shown highlighted in yellow:</span></span>  

    [!code-csharp[Main](aspnet-web-forms-connection-resiliency-and-command-interception/samples/sample2.cs?highlight=6)]
3. <span data-ttu-id="ea6ae-151">添加`catch`阻止`AddProduct`方法，以便`RetryLimitExceededException`记录为用黄色突出显示：</span><span class="sxs-lookup"><span data-stu-id="ea6ae-151">Add a `catch` block to the `AddProduct` method so that the `RetryLimitExceededException` is logged as highlighted in yellow:</span></span>   

    [!code-csharp[Main](aspnet-web-forms-connection-resiliency-and-command-interception/samples/sample3.cs?highlight=14-15,17-22)]

<span data-ttu-id="ea6ae-152">通过添加`RetryLimitExceededException`异常，你可以提供更好地日志记录或向他们可以选择要再次尝试该过程的用户显示一条错误消息。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-152">By adding the `RetryLimitExceededException` exception, you can provide better logging or display an error message to the user where they can choose to try the process again.</span></span> <span data-ttu-id="ea6ae-153">通过捕获`RetryLimitExceededException`异常，可能是暂时性的唯一错误将已尝试并失败几次。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-153">By catching the `RetryLimitExceededException` exception, the only errors likely to be transient will already have been tried and failed several times.</span></span> <span data-ttu-id="ea6ae-154">返回的实际异常将包装在`RetryLimitExceededException`异常。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-154">The actual exception returned will be wrapped in the `RetryLimitExceededException` exception.</span></span> <span data-ttu-id="ea6ae-155">此外，你还将添加的一般 catch 块。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-155">In addition, you also added a general catch block.</span></span> <span data-ttu-id="ea6ae-156">有关详细信息`RetryLimitExceededException`异常，请参阅[实体框架连接复原 / 重试逻辑](https://msdn.microsoft.com/en-us/data/dn456835)。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-156">For more information about the `RetryLimitExceededException` exception, see [Entity Framework Connection Resiliency / Retry Logic](https://msdn.microsoft.com/en-us/data/dn456835).</span></span>

## <a name="command-interception"></a><span data-ttu-id="ea6ae-157">命令截获</span><span class="sxs-lookup"><span data-stu-id="ea6ae-157">Command interception</span></span>

<span data-ttu-id="ea6ae-158">现在，你已启用的重试策略，如何进行你测试以验证它是否按预期工作？</span><span class="sxs-lookup"><span data-stu-id="ea6ae-158">Now that you've turned on a retry policy, how do you test to verify that it is working as expected?</span></span> <span data-ttu-id="ea6ae-159">不会轻易地强制暂时性错误发生，尤其是当您在本地，运行和它将会特别困难，可以将实际的暂时性错误集成到自动的单元测试。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-159">It's not so easy to force a transient error to happen, especially when you're running locally, and it would be especially difficult to integrate actual transient errors into an automated unit test.</span></span> <span data-ttu-id="ea6ae-160">若要测试连接复原功能，需要一种方法将截获实体框架将发送到 SQL Server 的查询并将替换为通常暂时性异常类型的 SQL Server 响应。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-160">To test the connection resiliency feature, you need a way to intercept queries that Entity Framework sends to SQL Server and replace the SQL Server response with an exception type that is typically transient.</span></span>

<span data-ttu-id="ea6ae-161">此外可以使用查询截获，以实现云应用程序的最佳做法： 日志的延迟和成功或失败的所有调用到外部服务，例如数据库服务。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-161">You can also use query interception in order to implement a best practice for cloud applications: log the latency and success or failure of all calls to external services such as database services.</span></span>

<span data-ttu-id="ea6ae-162">在本教程的本部分中，你将使用实体框架的[*截获功能*](https://msdn.microsoft.com/data/dn469464)对于日志记录和模拟暂时性错误。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-162">In this section of the tutorial you'll use the Entity Framework's [*interception feature*](https://msdn.microsoft.com/data/dn469464) both for logging and for simulating transient errors.</span></span>

### <a name="create-a-logging-interface-and-class"></a><span data-ttu-id="ea6ae-163">创建日志记录接口和类</span><span class="sxs-lookup"><span data-stu-id="ea6ae-163">Create a logging interface and class</span></span>

<span data-ttu-id="ea6ae-164">日志记录的最佳做法是使用可完成的[ `interface` ](https://msdn.microsoft.com/library/ms173156.aspx)而不是硬编码调用`System.Diagnostics.Trace`或日志记录类。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-164">A best practice for logging is to do it by using an [`interface`](https://msdn.microsoft.com/library/ms173156.aspx) rather than hard-coding calls to `System.Diagnostics.Trace` or a logging class.</span></span> <span data-ttu-id="ea6ae-165">这使可更轻松地更改你的日志记录机制更高版本，如果你在某个时候需要执行该操作。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-165">That makes it easier to change your logging mechanism later if you ever need to do that.</span></span> <span data-ttu-id="ea6ae-166">因此在本部分中，你将创建日志记录接口和类来实现。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-166">So in this section, you'll create the logging interface and a class to implement it.</span></span>

<span data-ttu-id="ea6ae-167">根据上面的过程，您必须下载并打开**WingtipToys**示例 Visual Studio 中的应用程序。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-167">Based on the above procedure, you have downloaded and opened the **WingtipToys** sample application in Visual Studio.</span></span>

1. <span data-ttu-id="ea6ae-168">中创建一个文件夹**WingtipToys**项目并将其命名*日志记录*。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-168">Create a folder in the **WingtipToys** project and name it *Logging*.</span></span>
2. <span data-ttu-id="ea6ae-169">在*日志记录*文件夹中，创建一个名为的类文件*ILogger.cs*和默认代码替换为以下代码：</span><span class="sxs-lookup"><span data-stu-id="ea6ae-169">In the *Logging* folder, create a class file named *ILogger.cs* and replace the default code with the following code:</span></span>  

    [!code-csharp[Main](aspnet-web-forms-connection-resiliency-and-command-interception/samples/sample4.cs)]

 <span data-ttu-id="ea6ae-170">该接口提供三种跟踪级别，以指示日志的相对重要性和旨在提供有关外部服务调用，如数据库查询的滞后时间信息的一个。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-170">The interface provides three tracing levels to indicate the relative importance of logs, and one designed to provide latency information for external service calls such as database queries.</span></span> <span data-ttu-id="ea6ae-171">日志记录方法具有重载，可以传递引发异常。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-171">The logging methods have overloads that let you pass in an exception.</span></span> <span data-ttu-id="ea6ae-172">这是以便实现的接口，而不是依靠中每个日志记录方法调用在整个应用程序正在执行的类可靠地记录异常信息包括堆栈跟踪和内部异常。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-172">This is so that exception information including stack trace and inner exceptions is reliably logged by the class that implements the interface, instead of relying on that being done in each logging method call throughout the application.</span></span>  
  
 <span data-ttu-id="ea6ae-173">`TraceApi`方法使你能够跟踪的 SQL 数据库等外部服务每次调用的延迟。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-173">The `TraceApi` methods enable you to track the latency of each call to an external service such as SQL Database.</span></span>
3. <span data-ttu-id="ea6ae-174">在*日志记录*文件夹中，创建一个名为的类文件*Logger.cs*和默认代码替换为以下代码：</span><span class="sxs-lookup"><span data-stu-id="ea6ae-174">In the *Logging* folder, create a class file named *Logger.cs* and replace the default code with the following code:</span></span>  

    [!code-csharp[Main](aspnet-web-forms-connection-resiliency-and-command-interception/samples/sample5.cs)]

<span data-ttu-id="ea6ae-175">实现使用`System.Diagnostics`以执行跟踪。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-175">The implementation uses `System.Diagnostics` to do the tracing.</span></span> <span data-ttu-id="ea6ae-176">这是可以轻松地生成和使用跟踪信息的.NET 的内置功能。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-176">This is a built-in feature of .NET which makes it easy to generate and use tracing information.</span></span> <span data-ttu-id="ea6ae-177">有许多&quot;侦听器&quot;可与`System.Diagnostics`日志写入文件，例如，或将它们写入 Windows Azure 中的 blob 存储的跟踪。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-177">There are many &quot;listeners&quot; you can use with `System.Diagnostics` tracing, to write logs to files, for example, or to write them to blob storage in Windows Azure.</span></span> <span data-ttu-id="ea6ae-178">在看到某些选项，以及指向其他资源的详细信息， [Troubleshooting Visual Studio 中 Windows Azure Web Sites](https://docs.microsoft.com/azure/app-service-web/web-sites-dotnet-troubleshoot-visual-studio)。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-178">See some of the options, and links to other resources for more information, in [Troubleshooting Windows Azure Web Sites in Visual Studio](https://docs.microsoft.com/azure/app-service-web/web-sites-dotnet-troubleshoot-visual-studio).</span></span> <span data-ttu-id="ea6ae-179">对于本教程，你将仅查看 Visual Studio 中的日志**输出**窗口。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-179">For this tutorial, you'll only look at logs in the Visual Studio **Output** window.</span></span>

<span data-ttu-id="ea6ae-180">在生产应用程序中，你可能需要考虑使用跟踪框架不`System.Diagnostics`，和`ILogger`接口可以相对轻松地切换到不同的跟踪机制，如果你决定要执行该操作。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-180">In a production application you might want to consider using tracing frameworks other than `System.Diagnostics`, and the `ILogger` interface makes it relatively easy to switch to a different tracing mechanism if you decide to do that.</span></span>

### <a name="create-interceptor-classes"></a><span data-ttu-id="ea6ae-181">创建侦听器类</span><span class="sxs-lookup"><span data-stu-id="ea6ae-181">Create interceptor classes</span></span>

<span data-ttu-id="ea6ae-182">接下来，你将创建每次它要将查询发送到数据库来模拟暂时性错误，其中进行日志记录时，实体框架将调入的类。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-182">Next, you'll create the classes that the Entity Framework will call into every time it is going to send a query to the database, one to simulate transient errors and one to do logging.</span></span> <span data-ttu-id="ea6ae-183">这些侦听器类必须派生自`DbCommandInterceptor`类。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-183">These interceptor classes must derive from the `DbCommandInterceptor` class.</span></span> <span data-ttu-id="ea6ae-184">在它们，编写查询是将要执行时，将自动调用的方法重写。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-184">In them, you write method overrides that are automatically called when the query is about to be executed.</span></span> <span data-ttu-id="ea6ae-185">您可以在这些方法可以检查或日志查询正被发送到数据库，并可以更改查询发送到数据库之前，也可以返回某些内容到实体框架自己而无需甚至传递到数据库的查询。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-185">In these methods you can examine or log the query that is being sent to the database, and you can change the query before it's sent to the database or return something to Entity Framework yourself without even passing the query to the database.</span></span>

1. <span data-ttu-id="ea6ae-186">若要创建发送到数据库之前，将记录每个 SQL 查询拦截器类，创建一个名为的类文件*InterceptorLogging.cs*中*逻辑*文件夹并将默认代码与以下代码：</span><span class="sxs-lookup"><span data-stu-id="ea6ae-186">To create the interceptor class that will log every SQL query before it is sent to the database, create a class file named *InterceptorLogging.cs* in the *Logic* folder and replace the default code with the following code:</span></span>  

    [!code-csharp[Main](aspnet-web-forms-connection-resiliency-and-command-interception/samples/sample6.cs)]

 <span data-ttu-id="ea6ae-187">对于成功的查询或命令，此代码将与滞后时间信息的信息日志。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-187">For successful queries or commands, this code writes an Information log with latency information.</span></span> <span data-ttu-id="ea6ae-188">对于异常，它将创建错误日志。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-188">For exceptions, it creates an Error log.</span></span>
2. <span data-ttu-id="ea6ae-189">若要创建在输入时，将生成 dummy 暂时性错误的侦听器类&quot;引发&quot;中**名称**上名为的页的文本框中*AdminPage.aspx*，创建一个类名为文件*InterceptorTransientErrors.cs*中*逻辑*文件夹和替换默认代码替换为以下代码：</span><span class="sxs-lookup"><span data-stu-id="ea6ae-189">To create the interceptor class that will generate dummy transient errors when you enter &quot;Throw&quot; in the **Name** textbox on the page named *AdminPage.aspx*, create a class file named *InterceptorTransientErrors.cs* in the *Logic* folder and replace the default code with the following code:</span></span>  

    [!code-csharp[Main](aspnet-web-forms-connection-resiliency-and-command-interception/samples/sample7.cs)]

    <span data-ttu-id="ea6ae-190">此代码仅重写`ReaderExecuting`方法，该调用可以返回多行数据的查询方法。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-190">This code only overrides the `ReaderExecuting` method, which is called for queries that can return multiple rows of data.</span></span> <span data-ttu-id="ea6ae-191">如果你想要检查连接复原对于其他类型的查询，也可以重写`NonQueryExecuting`和`ScalarExecuting`方法，为日志记录侦听器未。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-191">If you wanted to check connection resiliency for other types of queries, you could also override the `NonQueryExecuting` and `ScalarExecuting` methods, as the logging interceptor does.</span></span>  
  
 <span data-ttu-id="ea6ae-192">更高版本，你将登录为"Admin"，并选择**管理员**顶部导航栏上的链接。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-192">Later, you will log in as the "Admin" and select the **Admin** link on the top navigation bar.</span></span> <span data-ttu-id="ea6ae-193">然后，在*AdminPage.aspx*页将添加名为产品&quot;引发&quot;。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-193">Then, on the *AdminPage.aspx* page you will add a product named &quot;Throw&quot;.</span></span> <span data-ttu-id="ea6ae-194">该代码创建错误号 20，类型是已知是通常暂时性 dummy SQL 数据库的异常。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-194">The code creates a dummy SQL Database exception for error number 20, a type known to be typically transient.</span></span> <span data-ttu-id="ea6ae-195">其他当前被识别为暂时性的错误号均 64、 233、 10053、 10054、 10060、 10928、 10929、 40197、 40501 和 40613，但它们是可能会有新版本的 SQL 数据库中的更改。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-195">Other error numbers currently recognized as transient are 64, 233, 10053, 10054, 10060, 10928, 10929, 40197, 40501, and 40613, but these are subject to change in new versions of SQL Database.</span></span> <span data-ttu-id="ea6ae-196">产品将重命名为"TransientErrorExample"，可在代码中遵循*InterceptorTransientErrors.cs*文件。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-196">The product will be renamed to "TransientErrorExample", which you can follow in the code of the *InterceptorTransientErrors.cs* file.</span></span>  
  
 <span data-ttu-id="ea6ae-197">代码会返回该异常对 Entity Framework 而不是运行查询并通过返回结果。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-197">The code returns the exception to Entity Framework instead of running the query and passing back results.</span></span> <span data-ttu-id="ea6ae-198">返回暂时性异常*四个*次，然后将代码恢复到将查询传递给数据库的一般过程。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-198">The transient exception is returned *four* times, and then the code reverts to the normal procedure of passing the query to the database.</span></span>

    <span data-ttu-id="ea6ae-199">记录的所有内容，因为你将能够看到实体框架尝试之后才最后成功，四次执行查询和应用程序中的唯一区别是，它使用更长时间才能呈现包含查询结果页。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-199">Because everything is logged, you'll be able to see that Entity Framework tries to execute the query four times before finally succeeding, and the only difference in the application is that it takes longer to render a page with query results.</span></span>  
  
 <span data-ttu-id="ea6ae-200">实体框架将重试次数是可配置;该代码指定四次，因为它是 SQL 数据库执行策略的默认值。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-200">The number of times the Entity Framework will retry is configurable; the code specifies four times because that's the default value for the SQL Database execution policy.</span></span> <span data-ttu-id="ea6ae-201">如果更改执行策略，则必须还更改此处指定多少次暂时性错误生成的代码。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-201">If you change the execution policy, you'd also change the code here that specifies how many times transient errors are generated.</span></span> <span data-ttu-id="ea6ae-202">您还可以更改代码以生成更多的异常，使实体框架将引发`RetryLimitExceededException`异常。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-202">You could also change the code to generate more exceptions so that Entity Framework will throw the `RetryLimitExceededException` exception.</span></span>
3. <span data-ttu-id="ea6ae-203">在*Global.asax*，添加以下 using 语句：</span><span class="sxs-lookup"><span data-stu-id="ea6ae-203">In *Global.asax*, add the following using statements:</span></span>  

    [!code-csharp[Main](aspnet-web-forms-connection-resiliency-and-command-interception/samples/sample8.cs)]
4. <span data-ttu-id="ea6ae-204">然后，将添加到突出显示的行`Application_Start`方法：</span><span class="sxs-lookup"><span data-stu-id="ea6ae-204">Then, add the highlighted lines to the `Application_Start` method:</span></span>  

    [!code-csharp[Main](aspnet-web-forms-connection-resiliency-and-command-interception/samples/sample9.cs?highlight=17-20)]

<span data-ttu-id="ea6ae-205">这些代码行是什么因素会导致拦截器代码可在实体框架会将查询发送到数据库时运行。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-205">These lines of code are what causes your interceptor code to be run when Entity Framework sends queries to the database.</span></span> <span data-ttu-id="ea6ae-206">请注意，因为创建单独的拦截器类进行暂时性错误模拟和日志记录，你可以单独启用和禁用它们。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-206">Notice that because you created separate interceptor classes for transient error simulation and logging, you can independently enable and disable them.</span></span>   
  
 <span data-ttu-id="ea6ae-207">你可以将拦截器添加使用`DbInterception.Add`方法任何位置中你的代码; 它不一定要处于`Application_Start`方法。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-207">You can add interceptors using the `DbInterception.Add` method anywhere in your code; it doesn't have to be in the `Application_Start` method.</span></span> <span data-ttu-id="ea6ae-208">另一个选项，如果你未将拦截器添加在`Application_Start`方法，可以更新或添加名为的类*WingtipToysConfiguration.cs*和将上述代码中的构造函数末尾`WingtipToysbConfiguration`类。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-208">Another option, if you didn't add interceptors in the `Application_Start` method, would be to update or add the class named *WingtipToysConfiguration.cs* and put the above code at the end of the constructor of the `WingtipToysbConfiguration` class.</span></span>

<span data-ttu-id="ea6ae-209">无论你将此代码放，请注意不要执行`DbInterception.Add`对于相同的侦听器超过一次，或你将获取其他拦截器实例。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-209">Wherever you put this code, be careful not to execute `DbInterception.Add` for the same interceptor more than once, or you'll get additional interceptor instances.</span></span> <span data-ttu-id="ea6ae-210">例如，如果两次添加日志记录拦截器，你将看到为每个 SQL 查询的两个日志。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-210">For example, if you add the logging interceptor twice, you'll see two logs for every SQL query.</span></span>

<span data-ttu-id="ea6ae-211">拦截器执行顺序注册 (的顺序`DbInterception.Add`调用方法)。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-211">Interceptors are executed in the order of registration (the order in which the `DbInterception.Add` method is called).</span></span> <span data-ttu-id="ea6ae-212">顺序可能重要具体取决于您所做侦听器中。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-212">The order might matter depending on what you're doing in the interceptor.</span></span> <span data-ttu-id="ea6ae-213">例如，侦听器可能会更改获取中的 SQL 命令`CommandText`属性。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-213">For example, an interceptor might change the SQL command that it gets in the `CommandText` property.</span></span> <span data-ttu-id="ea6ae-214">如果它未更改的 SQL 命令下, 一步侦听器将获取已更改的 SQL 命令，而不是原始的 SQL 命令。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-214">If it does change the SQL command, the next interceptor will get the changed SQL command, not the original SQL command.</span></span>

<span data-ttu-id="ea6ae-215">你可以通过在 UI 中输入不同的值导致暂时性错误的方式编写的暂时性错误模拟代码。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-215">You've written the transient error simulation code in a way that lets you cause transient errors by entering a different value in the UI.</span></span> <span data-ttu-id="ea6ae-216">作为替代方法，你可以编写拦截器代码以始终生成暂时性异常的序列，而检查有特定的参数值。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-216">As an alternative, you could write the interceptor code to always generate the sequence of transient exceptions without checking for a particular parameter value.</span></span> <span data-ttu-id="ea6ae-217">仅当你想要生成暂时性错误，然后可以添加侦听器。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-217">You could then add the interceptor only when you want to generate transient errors.</span></span> <span data-ttu-id="ea6ae-218">如果这样做，但是，在数据库初始化完成后不添加直到侦听器。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-218">If you do this, however, don't add the interceptor until after database initialization has completed.</span></span> <span data-ttu-id="ea6ae-219">在开始生成暂时性错误之前，换而言之，执行如查询实体集之一上的至少一个数据库操作。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-219">In other words, do at least one database operation such as a query on one of your entity sets before you start generating transient errors.</span></span> <span data-ttu-id="ea6ae-220">实体框架在数据库初始化期间所执行多个查询和它们不执行在事务中，因此在初始化期间的错误可能会导致才能进入不一致状态的上下文。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-220">The Entity Framework executes several queries during database initialization, and they aren't executed in a transaction, so errors during initialization could cause the context to get into an inconsistent state.</span></span>

## <a name="test-logging-and-connection-resiliency"></a><span data-ttu-id="ea6ae-221">测试日志记录和连接复原</span><span class="sxs-lookup"><span data-stu-id="ea6ae-221">Test logging and connection resiliency</span></span>

1. <span data-ttu-id="ea6ae-222">在 Visual Studio 中，按**F5**运行该应用程序在调试模式，然后为"Admin"，然后使用"Pa$ $word"作为密码登录。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-222">In Visual Studio, press **F5** to run the application in debug mode, and then login as "Admin" using "Pa$$word" as the password.</span></span>
2. <span data-ttu-id="ea6ae-223">选择**管理员**顶部导航栏中。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-223">Select **Admin** from the navigation bar at the top.</span></span>
3. <span data-ttu-id="ea6ae-224">输入新的产品名为"引发"与相应的说明、 价格和图像文件。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-224">Enter a new product named "Throw" with appropriate description, price and image file.</span></span>
4. <span data-ttu-id="ea6ae-225">按**添加产品**按钮。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-225">Press the **Add Product** button.</span></span>  
 <span data-ttu-id="ea6ae-226">你会注意到，浏览器看上去已挂起了几秒钟时实体框架重试查询多次。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-226">You'll notice that the browser seems to hang for several seconds while Entity Framework is retrying the query several times.</span></span> <span data-ttu-id="ea6ae-227">首次重试发生速度非常快，然后在每个其他的重试之前的等待增大。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-227">The first retry happens very quickly, then the wait increases before each additional retry.</span></span> <span data-ttu-id="ea6ae-228">此过程的调用每次重试之前再等待*指数退让*。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-228">This process of waiting longer before each retry is called *exponential backoff* .</span></span>
5. <span data-ttu-id="ea6ae-229">等待，直到页面不再 atttempting 加载。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-229">Wait until the page is no longer atttempting to load.</span></span>
6. <span data-ttu-id="ea6ae-230">停止项目，并查看 Visual Studio**输出**窗口以查看跟踪输出。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-230">Stop the project and look at the Visual Studio **Output** window to see the tracing output.</span></span> <span data-ttu-id="ea6ae-231">你可以找到**输出**窗口，通过选择**调试** - &gt; **Windows**  - &gt; **输出**。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-231">You can find the **Output** window by selecting **Debug** -&gt; **Windows** -&gt; **Output**.</span></span> <span data-ttu-id="ea6ae-232">你可能必须滚动条越过数据编写你记录器的几个其他日志。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-232">You might have to scroll past several other logs written by your logger.</span></span>  
  
 <span data-ttu-id="ea6ae-233">请注意，你可以看到发送到数据库的实际 SQL 查询。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-233">Notice that you can see the actual SQL queries sent to the database.</span></span> <span data-ttu-id="ea6ae-234">你看到一些初始查询和命令的实体框架执行的操作若要开始，检查数据库版本和迁移历史记录表。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-234">You see some initial queries and commands that Entity Framework does to get started, checking the database version and migration history table.</span></span>   
    <span data-ttu-id="ea6ae-235">![输出窗口](aspnet-web-forms-connection-resiliency-and-command-interception/_static/image1.png) </span><span class="sxs-lookup"><span data-stu-id="ea6ae-235">![Output Window](aspnet-web-forms-connection-resiliency-and-command-interception/_static/image1.png) </span></span>  
 <span data-ttu-id="ea6ae-236">请注意，不能重复此测试，除非停止应用程序并重新启动它。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-236">Note that you can't repeat this test unless you stop the application and restart it.</span></span> <span data-ttu-id="ea6ae-237">如果你想要能够在应用程序的单次运行中测试连接复原多次，你可以编写代码以重置中的错误计数器`InterceptorTransientErrors`。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-237">If you wanted to be able to test connection resiliency multiple times in a single run of the application, you could write code to reset the error counter in `InterceptorTransientErrors` .</span></span>
7. <span data-ttu-id="ea6ae-238">可以查看的差异 （重试策略） 的执行策略进行，注释`SetExecutionStrategy`中一行*WingtipToysConfiguration.cs*文件中*逻辑*文件夹中，运行**管理员**同样，在调试模式下页上，添加名为产品&quot;引发&quot;试。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-238">To see the difference the execution strategy (retry policy) makes, comment out the `SetExecutionStrategy` line in *WingtipToysConfiguration.cs* file in the *Logic* folder, run the **Admin** page in debug mode again, and add the product named &quot;Throw&quot; again.</span></span>  
  
 <span data-ttu-id="ea6ae-239">这一次调试器停止上第一次生成异常立即时它将尝试执行第一次的查询。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-239">This time the debugger stops on the first generated exception immediately when it tries to execute the query the first time.</span></span>  
    ![调试-查看详细信息](aspnet-web-forms-connection-resiliency-and-command-interception/_static/image2.png)
8. <span data-ttu-id="ea6ae-241">取消注释`SetExecutionStrategy`中一行*WingtipToysConfiguration.cs*文件。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-241">Uncomment the `SetExecutionStrategy` line in the *WingtipToysConfiguration.cs* file.</span></span>

## <a name="summary"></a><span data-ttu-id="ea6ae-242">摘要</span><span class="sxs-lookup"><span data-stu-id="ea6ae-242">Summary</span></span>

<span data-ttu-id="ea6ae-243">在本教程中，你已了解如何修改 Web 窗体示例应用程序，以支持连接复原和命令截获。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-243">In this tutorial you've seen how to modify a Web Forms sample application to support connection resiliency and command interception.</span></span>

## <a name="next-steps"></a><span data-ttu-id="ea6ae-244">后续步骤</span><span class="sxs-lookup"><span data-stu-id="ea6ae-244">Next Steps</span></span>

<span data-ttu-id="ea6ae-245">查看连接复原和 ASP.NET Web 窗体中的命令截获后，查看 ASP.NET Web 窗体主题[ASP.NET 4.5 中的异步方法](../performance-and-caching/using-asynchronous-methods-in-aspnet-45.md)。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-245">After you have reviewed connection resiliency and command interception in ASP.NET Web Forms, review the ASP.NET Web Forms topic [Asynchronous Methods in ASP.NET 4.5](../performance-and-caching/using-asynchronous-methods-in-aspnet-45.md).</span></span> <span data-ttu-id="ea6ae-246">本主题将教您生成使用 Visual Studio 的异步 ASP.NET Web 窗体应用程序的基础知识。</span><span class="sxs-lookup"><span data-stu-id="ea6ae-246">The topic will teach you the basics of building an asynchronous ASP.NET Web Forms application using Visual Studio.</span></span>
