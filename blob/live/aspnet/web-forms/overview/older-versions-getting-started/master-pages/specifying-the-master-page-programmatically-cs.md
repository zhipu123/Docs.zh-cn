---
uid: web-forms/overview/older-versions-getting-started/master-pages/specifying-the-master-page-programmatically-cs
title: "以编程方式指定 Master 页 (C#) |Microsoft 文档"
author: rick-anderson
description: "查看设置内容页的母版页以编程方式通过 PreInit 事件处理程序。"
ms.author: aspnetcontent
manager: wpickett
ms.date: 07/28/2008
ms.topic: article
ms.assetid: 7c4a3445-2440-4aee-b9fd-779c05e6abb2
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/older-versions-getting-started/master-pages/specifying-the-master-page-programmatically-cs
msc.type: authoredcontent
ms.openlocfilehash: 57ac8052223c1fd00bff8df1c3180db8bea8d38a
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/10/2017
---
<a name="specifying-the-master-page-programmatically-c"></a><span data-ttu-id="e1921-103">以编程方式指定 Master 页 (C#)</span><span class="sxs-lookup"><span data-stu-id="e1921-103">Specifying the Master Page Programmatically (C#)</span></span>
====================
<span data-ttu-id="e1921-104">通过[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="e1921-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="e1921-105">[下载代码](http://download.microsoft.com/download/d/6/6/d66ad554-afdd-409e-a5c3-201b774fbb31/ASPNET_MasterPages_Tutorial_09_CS.zip)或[下载 PDF](http://download.microsoft.com/download/d/6/6/d66ad554-afdd-409e-a5c3-201b774fbb31/ASPNET_MasterPages_Tutorial_09_CS.pdf)</span><span class="sxs-lookup"><span data-stu-id="e1921-105">[Download Code](http://download.microsoft.com/download/d/6/6/d66ad554-afdd-409e-a5c3-201b774fbb31/ASPNET_MasterPages_Tutorial_09_CS.zip) or [Download PDF](http://download.microsoft.com/download/d/6/6/d66ad554-afdd-409e-a5c3-201b774fbb31/ASPNET_MasterPages_Tutorial_09_CS.pdf)</span></span>

> <span data-ttu-id="e1921-106">查看设置内容页的母版页以编程方式通过 PreInit 事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="e1921-106">Looks at setting the content page's master page programmatically via the PreInit event handler.</span></span>


## <a name="introduction"></a><span data-ttu-id="e1921-107">介绍</span><span class="sxs-lookup"><span data-stu-id="e1921-107">Introduction</span></span>

<span data-ttu-id="e1921-108">中的篇示例以来[*创建站点范围布局使用 Master 页*](creating-a-site-wide-layout-using-master-pages-cs.md)，所有内容页引用以声明方式通过其母版页`MasterPageFile`中属性`@Page`指令。</span><span class="sxs-lookup"><span data-stu-id="e1921-108">Since the inaugural example in [*Creating a Site-Wide Layout Using Master Pages*](creating-a-site-wide-layout-using-master-pages-cs.md), all content pages have referenced their master page declaratively via the `MasterPageFile` attribute in the `@Page` directive.</span></span> <span data-ttu-id="e1921-109">例如，以下`@Page`指令链接到的主页面的内容页`Site.master`:</span><span class="sxs-lookup"><span data-stu-id="e1921-109">For example, the following `@Page` directive links the content page to the master page `Site.master`:</span></span>


[!code-aspx[Main](specifying-the-master-page-programmatically-cs/samples/sample1.aspx)]

<span data-ttu-id="e1921-110">[ `Page`类](https://msdn.microsoft.com/en-us/library/system.web.ui.page.aspx)中`System.Web.UI`命名空间包括[`MasterPageFile`属性](https://msdn.microsoft.com/en-us/library/system.web.ui.page.masterpagefile.aspx)，将路径返回到内容页的母版页; 它是由设置此属性`@Page`指令。</span><span class="sxs-lookup"><span data-stu-id="e1921-110">The [`Page` class](https://msdn.microsoft.com/en-us/library/system.web.ui.page.aspx) in the `System.Web.UI` namespace includes a [`MasterPageFile` property](https://msdn.microsoft.com/en-us/library/system.web.ui.page.masterpagefile.aspx) that returns the path to the content page's master page; it is this property that is set by the `@Page` directive.</span></span> <span data-ttu-id="e1921-111">此属性还可以用于以编程方式指定内容页的母版页。</span><span class="sxs-lookup"><span data-stu-id="e1921-111">This property can also be used to programmatically specify the content page's master page.</span></span> <span data-ttu-id="e1921-112">此方法非常有用，如果你想要动态分配母版页基于外部因素，例如访问的页面的用户。</span><span class="sxs-lookup"><span data-stu-id="e1921-112">This approach is useful if you want to dynamically assign the master page based on external factors, such as the user visiting the page.</span></span>

<span data-ttu-id="e1921-113">在本教程中我们将第二个母版页添加到我们的网站，并动态决定要在运行时使用的主页面。</span><span class="sxs-lookup"><span data-stu-id="e1921-113">In this tutorial we add a second master page to our website and dynamically decide which master page to use at runtime.</span></span>

## <a name="step-1-a-look-at-the-page-lifecycle"></a><span data-ttu-id="e1921-114">步骤 1： 查看页面生命周期</span><span class="sxs-lookup"><span data-stu-id="e1921-114">Step 1: A Look at the Page Lifecycle</span></span>

<span data-ttu-id="e1921-115">每当请求到达 web 服务器是内容页的 ASP.NET 页时，ASP.NET 引擎必须保险丝页面的内容控件添加到母版页的对应 ContentPlaceHolder 控件。</span><span class="sxs-lookup"><span data-stu-id="e1921-115">Whenever a request arrives at the web server for an ASP.NET page that is a content page, the ASP.NET engine must fuse the page's Content controls into the master page's corresponding ContentPlaceHolder controls.</span></span> <span data-ttu-id="e1921-116">此合成创建然后可以继续完成典型的页面生命周期的单个控件层次结构。</span><span class="sxs-lookup"><span data-stu-id="e1921-116">This fusion creates a single control hierarchy that can then proceed through the typical page lifecycle.</span></span>

<span data-ttu-id="e1921-117">图 1 说明此合成。</span><span class="sxs-lookup"><span data-stu-id="e1921-117">Figure 1 illustrates this fusion.</span></span> <span data-ttu-id="e1921-118">步骤 1 中图 1 显示了初始内容和母版页控件层次结构。</span><span class="sxs-lookup"><span data-stu-id="e1921-118">Step 1 in Figure 1 shows the initial content and master page control hierarchies.</span></span> <span data-ttu-id="e1921-119">末端的 PreInit 阶段内容页中的控件将添加到相应 ContentPlaceHolders 母版页 (步骤 2) 中。</span><span class="sxs-lookup"><span data-stu-id="e1921-119">At the tail end of the PreInit stage the Content controls in the page are added to the corresponding ContentPlaceHolders in the master page (Step 2).</span></span> <span data-ttu-id="e1921-120">在此合成后母版页用作融合的控件层次结构的根。</span><span class="sxs-lookup"><span data-stu-id="e1921-120">After this fusion, the master page serves as the root of the fused control hierarchy.</span></span> <span data-ttu-id="e1921-121">这在打印控件层次结构随后添加到页后，可以生成完成的控件层次结构 (步骤 3)。</span><span class="sxs-lookup"><span data-stu-id="e1921-121">This fused control hierarchy is then added to the page to produce the finalized control hierarchy (Step 3).</span></span> <span data-ttu-id="e1921-122">最终结果是页的控件层次结构包含融合的控件层次结构。</span><span class="sxs-lookup"><span data-stu-id="e1921-122">The net result is that the page's control hierarchy includes the fused control hierarchy.</span></span>


<span data-ttu-id="e1921-123">[![母版页和内容页的控件层次结构排列 Fused PreInit 阶段](specifying-the-master-page-programmatically-cs/_static/image2.png)](specifying-the-master-page-programmatically-cs/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="e1921-123">[![The Master Page and Content Page's Control Hierarchies are Fused Together during the PreInit Stage](specifying-the-master-page-programmatically-cs/_static/image2.png)](specifying-the-master-page-programmatically-cs/_static/image1.png)</span></span>

<span data-ttu-id="e1921-124">**图 01**： 在母版页和内容页的控件层次结构排列 Fused PreInit 阶段 ([单击以查看实际尺寸的图像](specifying-the-master-page-programmatically-cs/_static/image3.png))</span><span class="sxs-lookup"><span data-stu-id="e1921-124">**Figure 01**: The Master Page and Content Page's Control Hierarchies are Fused Together during the PreInit Stage ([Click to view full-size image](specifying-the-master-page-programmatically-cs/_static/image3.png))</span></span>


## <a name="step-2-setting-themasterpagefileproperty-from-code"></a><span data-ttu-id="e1921-125">步骤 2： 设置`MasterPageFile`代码中的属性</span><span class="sxs-lookup"><span data-stu-id="e1921-125">Step 2: Setting the`MasterPageFile`Property from Code</span></span>

<span data-ttu-id="e1921-126">在此合成 partakes 哪些母版页依赖于的值`Page`对象的`MasterPageFile`属性。</span><span class="sxs-lookup"><span data-stu-id="e1921-126">What master page partakes in this fusion depends on the value of the `Page` object's `MasterPageFile` property.</span></span> <span data-ttu-id="e1921-127">设置`MasterPageFile`属性中`@Page`指令有分配的净效果`Page`的`MasterPageFile`在初始化阶段，即该页面的生命周期的第一个阶段的属性。</span><span class="sxs-lookup"><span data-stu-id="e1921-127">Setting the `MasterPageFile` attribute in the `@Page` directive has the net effect of assigning the `Page`'s `MasterPageFile` property during the Initialization stage, which is the very first stage of the page's lifecycle.</span></span> <span data-ttu-id="e1921-128">或者，我们可以以编程方式设置此属性。</span><span class="sxs-lookup"><span data-stu-id="e1921-128">We can alternatively set this property programmatically.</span></span> <span data-ttu-id="e1921-129">但是，它是命令性图 1 中的合成发生之前，设置此属性。</span><span class="sxs-lookup"><span data-stu-id="e1921-129">However, it is imperative that this property be set before the fusion in Figure 1 takes place.</span></span>

<span data-ttu-id="e1921-130">PreInit 阶段开始时`Page`对象引发其[`PreInit`事件](https://msdn.microsoft.com/en-us/library/system.web.ui.page.preinit.aspx)并调用其[`OnPreInit`方法](https://msdn.microsoft.com/en-us/library/system.web.ui.page.onpreinit.aspx)。</span><span class="sxs-lookup"><span data-stu-id="e1921-130">At the start of the PreInit stage the `Page` object raises its [`PreInit` event](https://msdn.microsoft.com/en-us/library/system.web.ui.page.preinit.aspx) and calls its [`OnPreInit` method](https://msdn.microsoft.com/en-us/library/system.web.ui.page.onpreinit.aspx).</span></span> <span data-ttu-id="e1921-131">若要以编程方式设置主控页，然后，我们可以创建的事件处理程序`PreInit`事件或替代`OnPreInit`方法。</span><span class="sxs-lookup"><span data-stu-id="e1921-131">To set the master page programmatically, then, we can either create an event handler for the `PreInit` event or override the `OnPreInit` method.</span></span> <span data-ttu-id="e1921-132">让我们看一下这两种方法。</span><span class="sxs-lookup"><span data-stu-id="e1921-132">Let's look at both approaches.</span></span>

<span data-ttu-id="e1921-133">首先打开`Default.aspx.cs`，我们站点的主页的代码隐藏类文件。</span><span class="sxs-lookup"><span data-stu-id="e1921-133">Start by opening `Default.aspx.cs`, the code-behind class file for our site's homepage.</span></span> <span data-ttu-id="e1921-134">添加事件处理程序为页的`PreInit`通过键入下面的代码中的事件：</span><span class="sxs-lookup"><span data-stu-id="e1921-134">Add an event handler for the page's `PreInit` event by typing in the following code:</span></span>


[!code-csharp[Main](specifying-the-master-page-programmatically-cs/samples/sample2.cs)]

<span data-ttu-id="e1921-135">从此处我们可以设置`MasterPageFile`属性。</span><span class="sxs-lookup"><span data-stu-id="e1921-135">From here we can set the `MasterPageFile` property.</span></span> <span data-ttu-id="e1921-136">更新代码，以便它将的值"~ / Site.master"到`MasterPageFile`属性。</span><span class="sxs-lookup"><span data-stu-id="e1921-136">Update the code so that it assigns the value "~/Site.master" to the `MasterPageFile` property.</span></span>


[!code-csharp[Main](specifying-the-master-page-programmatically-cs/samples/sample3.cs)]

<span data-ttu-id="e1921-137">如果设置断点并开始调试你将看到，每当`Default.aspx`网页访问，或者每当没有回发到此页上，`Page_PreInit`事件处理程序执行和`MasterPageFile`属性分配给"~ / Site.master"。</span><span class="sxs-lookup"><span data-stu-id="e1921-137">If you set a breakpoint and start with debugging you'll see that whenever the `Default.aspx` page is visited or whenever there's a postback to this page, the `Page_PreInit` event handler executes and the `MasterPageFile` property is assigned to "~/Site.master".</span></span>

<span data-ttu-id="e1921-138">或者，你可以重写`Page`类的`OnPreInit`方法和组`MasterPageFile`那里属性。</span><span class="sxs-lookup"><span data-stu-id="e1921-138">Alternatively, you can override the `Page` class's `OnPreInit` method and set the `MasterPageFile` property there.</span></span> <span data-ttu-id="e1921-139">对于此示例中，让我们不设置母版页中的特定页，而从`BasePage`。</span><span class="sxs-lookup"><span data-stu-id="e1921-139">For this example, let's not set the master page in a particular page, but rather from `BasePage`.</span></span> <span data-ttu-id="e1921-140">回想一下，我们创建了一个自定义的基本页类 (`BasePage`) 返回[*母版页中指定的标题、 Meta 标记和其他 HTML 标头*](specifying-the-title-meta-tags-and-other-html-headers-in-the-master-page-cs.md)教程。</span><span class="sxs-lookup"><span data-stu-id="e1921-140">Recall that we created a custom base page class (`BasePage`) back in the [*Specifying the Title, Meta Tags, and Other HTML Headers in the Master Page*](specifying-the-title-meta-tags-and-other-html-headers-in-the-master-page-cs.md) tutorial.</span></span> <span data-ttu-id="e1921-141">当前`BasePage`重写`Page`类的`OnLoadComplete`方法，它可以将设置页面的`Title`属性基于站点地图数据。</span><span class="sxs-lookup"><span data-stu-id="e1921-141">Currently `BasePage` overrides the `Page` class's `OnLoadComplete` method, where it sets the page's `Title` property based on the site map data.</span></span> <span data-ttu-id="e1921-142">让我们更新`BasePage`还重写`OnPreInit`方法以编程方式指定母版页。</span><span class="sxs-lookup"><span data-stu-id="e1921-142">Let's update `BasePage` to also override the `OnPreInit` method to programmatically specify the master page.</span></span>


[!code-csharp[Main](specifying-the-master-page-programmatically-cs/samples/sample4.cs)]

<span data-ttu-id="e1921-143">因为我们的所有内容页派生自`BasePage`，所有这些现在都以编程方式分配其母版页。</span><span class="sxs-lookup"><span data-stu-id="e1921-143">Because all our content pages derive from `BasePage`, all of them now have their master page programmatically assigned.</span></span> <span data-ttu-id="e1921-144">此时`PreInit`中的事件处理程序`Default.aspx.cs`是多余的; 请尝试将其删除。</span><span class="sxs-lookup"><span data-stu-id="e1921-144">At this point the `PreInit` event handler in `Default.aspx.cs` is superfluous; feel free to remove it.</span></span>

### <a name="what-about-thepagedirective"></a><span data-ttu-id="e1921-145">呢`@Page`指令？</span><span class="sxs-lookup"><span data-stu-id="e1921-145">What About the`@Page`Directive?</span></span>

<span data-ttu-id="e1921-146">新增功能可能有点令人困惑在于内容页的`MasterPageFile`属性现在在两个位置中指定： 以编程方式在`BasePage`类的`OnPreInit`方法以及通过`MasterPageFile`每个内容页面中的属性`@Page`指令。</span><span class="sxs-lookup"><span data-stu-id="e1921-146">What may be a little confusing is that the content pages' `MasterPageFile` properties are now being specified in two places: programmatically in the `BasePage` class's `OnPreInit` method as well as through the `MasterPageFile` attribute in each content page's `@Page` directive.</span></span>

<span data-ttu-id="e1921-147">页生命周期中的第一个阶段是初始化阶段。</span><span class="sxs-lookup"><span data-stu-id="e1921-147">The first stage in the page lifecycle is the Initialization stage.</span></span> <span data-ttu-id="e1921-148">在此阶段`Page`对象的`MasterPageFile`属性分配的值`MasterPageFile`属性中`@Page`指令 （如果提供）。</span><span class="sxs-lookup"><span data-stu-id="e1921-148">During this stage the `Page` object's `MasterPageFile` property is assigned the value of the `MasterPageFile` attribute in the `@Page` directive (if it is provided).</span></span> <span data-ttu-id="e1921-149">PreInit 阶段遵循初始化阶段中，并就在这里，我们以编程方式设置`Page`对象的`MasterPageFile`属性，从而覆盖从分配的值`@Page`指令。</span><span class="sxs-lookup"><span data-stu-id="e1921-149">The PreInit stage follows the Initialization stage, and it is here where we programmatically set the `Page` object's `MasterPageFile` property, thereby overwriting the value assigned from the `@Page` directive.</span></span> <span data-ttu-id="e1921-150">因为我们设置`Page`对象的`MasterPageFile`属性以编程方式，我们无法删除`MasterPageFile`属性从`@Page`指令而不会影响最终用户体验。</span><span class="sxs-lookup"><span data-stu-id="e1921-150">Because we are setting the `Page` object's `MasterPageFile` property programmatically, we could remove the `MasterPageFile` attribute from the `@Page` directive without affecting the end user's experience.</span></span> <span data-ttu-id="e1921-151">来说服您自己的这种情况，请继续并删除`MasterPageFile`属性从`@Page`指令`Default.aspx`，然后访问通过浏览器页面。</span><span class="sxs-lookup"><span data-stu-id="e1921-151">To convince yourself of this, go ahead and remove the `MasterPageFile` attribute from the `@Page` directive in `Default.aspx` and then visit the page through a browser.</span></span> <span data-ttu-id="e1921-152">如你所料，输出之前相同的属性已被删除。</span><span class="sxs-lookup"><span data-stu-id="e1921-152">As you would expect, the output is the same as before the attribute was removed.</span></span>

<span data-ttu-id="e1921-153">是否`MasterPageFile`通过设置属性`@Page`指令或以编程方式向最终用户体验无关紧要。</span><span class="sxs-lookup"><span data-stu-id="e1921-153">Whether the `MasterPageFile` property is set via the `@Page` directive or programmatically is inconsequential to the end user's experience.</span></span> <span data-ttu-id="e1921-154">但是，`MasterPageFile`属性中`@Page`指令由 Visual Studio 在设计时用于生成所见即所得视图设计器中的。</span><span class="sxs-lookup"><span data-stu-id="e1921-154">However, the `MasterPageFile` attribute in the `@Page` directive is used by Visual Studio during design-time to produce the WYSIWYG view in the Designer.</span></span> <span data-ttu-id="e1921-155">如果返回到`Default.aspx`Visual Studio 中，然后导航到设计器中，你将看到消息，"母版页错误： 页了控件需要母版页引用，但是未指定"（请参见图 2）。</span><span class="sxs-lookup"><span data-stu-id="e1921-155">If you return to `Default.aspx` in Visual Studio and navigate to the Designer you'll see the message, "Master Page error: The page has controls that require a Master Page reference, but none is specified" (see Figure 2).</span></span>

<span data-ttu-id="e1921-156">简单地说，您需要离开`MasterPageFile`属性中`@Page`指令以享受 Visual Studio 中丰富的设计时体验。</span><span class="sxs-lookup"><span data-stu-id="e1921-156">In short, you need to leave the `MasterPageFile` attribute in the `@Page` directive to enjoy a rich design-time experience in Visual Studio.</span></span>


<span data-ttu-id="e1921-157">[![Visual Studio 使用@Page指令的 MasterPageFile 属性呈现设计视图](specifying-the-master-page-programmatically-cs/_static/image5.png)](specifying-the-master-page-programmatically-cs/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="e1921-157">[![Visual Studio Uses the @Page Directive's MasterPageFile Attribute to Render the Design View](specifying-the-master-page-programmatically-cs/_static/image5.png)](specifying-the-master-page-programmatically-cs/_static/image4.png)</span></span>

<span data-ttu-id="e1921-158">**图 02**: Visual Studio 将使用`@Page`指令的`MasterPageFile`属性呈现到设计视图 ([单击以查看实际尺寸的图像](specifying-the-master-page-programmatically-cs/_static/image6.png))</span><span class="sxs-lookup"><span data-stu-id="e1921-158">**Figure 02**: Visual Studio Uses the `@Page` Directive's `MasterPageFile` Attribute to Render the Design View  ([Click to view full-size image](specifying-the-master-page-programmatically-cs/_static/image6.png))</span></span>


## <a name="step-3-creating-an-alternative-master-page"></a><span data-ttu-id="e1921-159">步骤 3： 创建的替代项母版页</span><span class="sxs-lookup"><span data-stu-id="e1921-159">Step 3: Creating an Alternative Master Page</span></span>

<span data-ttu-id="e1921-160">因为在运行时以编程方式设置内容页面的母版页则可以动态加载特定母版页根据某些外部标准。</span><span class="sxs-lookup"><span data-stu-id="e1921-160">Because a content page's master page can be set programmatically at runtime it's possible to dynamically load a particular master page based on some external criteria.</span></span> <span data-ttu-id="e1921-161">此功能可以在其中站点的布局需要改变根据用户的情况下有用。</span><span class="sxs-lookup"><span data-stu-id="e1921-161">This functionality can be useful in situations where the site's layout needs to vary based on the user.</span></span> <span data-ttu-id="e1921-162">例如，博客引擎 web 应用程序可能允许其用户选择其博客的布局其中每个布局是与不同的母版页相关联。</span><span class="sxs-lookup"><span data-stu-id="e1921-162">For instance, a blog engine web application may allow its users to choose a layout for their blog, where each layout is associated with a different master page.</span></span> <span data-ttu-id="e1921-163">在运行时，当访问者查看用户的博客，web 应用程序需要确定博客的布局和动态将相应的主控页的内容页与相关联。</span><span class="sxs-lookup"><span data-stu-id="e1921-163">At runtime, when a visitor is viewing a user's blog, the web application would need to determine the blog's layout and dynamically associate the corresponding master page with the content page.</span></span>

<span data-ttu-id="e1921-164">让我们看一下如何动态加载在运行时根据某些外部标准母版页。</span><span class="sxs-lookup"><span data-stu-id="e1921-164">Let's examine how to dynamically load a master page at runtime based on some external criteria.</span></span> <span data-ttu-id="e1921-165">我们的网站目前包含只在一个母版页 (`Site.master`)。</span><span class="sxs-lookup"><span data-stu-id="e1921-165">Our website currently contains just one master page (`Site.master`).</span></span> <span data-ttu-id="e1921-166">我们需要另一个主页面，以说明选择母版页在运行时。</span><span class="sxs-lookup"><span data-stu-id="e1921-166">We need another master page to illustrate choosing a master page at runtime.</span></span> <span data-ttu-id="e1921-167">此步骤重点介绍创建和配置新的主控页。</span><span class="sxs-lookup"><span data-stu-id="e1921-167">This step focuses on creating and configuring the new master page.</span></span> <span data-ttu-id="e1921-168">步骤 4 来看待确定哪些主页后，可以在运行时使用。</span><span class="sxs-lookup"><span data-stu-id="e1921-168">Step 4 looks at determining what master page to use at runtime.</span></span>

<span data-ttu-id="e1921-169">名为的根文件夹中创建新的母版页`Alternate.master`。</span><span class="sxs-lookup"><span data-stu-id="e1921-169">Create a new master page in the root folder named `Alternate.master`.</span></span> <span data-ttu-id="e1921-170">此外将新的样式表添加到名为的网站`AlternateStyles.css`。</span><span class="sxs-lookup"><span data-stu-id="e1921-170">Also add a new style sheet to the website named `AlternateStyles.css`.</span></span>


<span data-ttu-id="e1921-171">[![添加另一个母版页和 CSS 文件到网站](specifying-the-master-page-programmatically-cs/_static/image8.png)](specifying-the-master-page-programmatically-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="e1921-171">[![Add Another Master Page and CSS File to the Website](specifying-the-master-page-programmatically-cs/_static/image8.png)](specifying-the-master-page-programmatically-cs/_static/image7.png)</span></span>

<span data-ttu-id="e1921-172">**图 03**： 添加另一个母版页和 CSS 文件到网站 ([单击以查看实际尺寸的图像](specifying-the-master-page-programmatically-cs/_static/image9.png))</span><span class="sxs-lookup"><span data-stu-id="e1921-172">**Figure 03**: Add Another Master Page and CSS File to the Website ([Click to view full-size image](specifying-the-master-page-programmatically-cs/_static/image9.png))</span></span>


<span data-ttu-id="e1921-173">我已设计`Alternate.master`母版页能够在顶部的页上，居中和深蓝色背景上显示的标题。</span><span class="sxs-lookup"><span data-stu-id="e1921-173">I've designed the `Alternate.master` master page to have the title displayed at the top of the page, centered and on a navy background.</span></span> <span data-ttu-id="e1921-174">我已分配的左侧列，移动下的该内容`MainContent`ContentPlaceHolder 控件，现在跨越页面的整个宽度。</span><span class="sxs-lookup"><span data-stu-id="e1921-174">I've dispensed of the left column and moved that content beneath the `MainContent` ContentPlaceHolder control, which now spans the entire width of the page.</span></span> <span data-ttu-id="e1921-175">此外，我 nixed 未经排序的课程列表并替换水平上列`MainContent`。</span><span class="sxs-lookup"><span data-stu-id="e1921-175">Furthermore, I nixed the unordered Lessons list and replaced it with a horizontal list above `MainContent`.</span></span> <span data-ttu-id="e1921-176">我也已更新的字体和颜色的母版页 （和使用，通过扩展，其内容页）。</span><span class="sxs-lookup"><span data-stu-id="e1921-176">I also updated the fonts and colors used by the master page (and, by extension, its content pages).</span></span> <span data-ttu-id="e1921-177">图 4 显示`Default.aspx`时使用`Alternate.master`母版页。</span><span class="sxs-lookup"><span data-stu-id="e1921-177">Figure 4 shows `Default.aspx` when using the `Alternate.master` master page.</span></span>

> [!NOTE]
> <span data-ttu-id="e1921-178">ASP.NET 包括能够定义*主题*。</span><span class="sxs-lookup"><span data-stu-id="e1921-178">ASP.NET includes the ability to define *Themes*.</span></span> <span data-ttu-id="e1921-179">主题是图像、 CSS 文件和与样式有关的 Web 控件属性设置。 可以应用于在运行时的页的集合。</span><span class="sxs-lookup"><span data-stu-id="e1921-179">A Theme is a collection of images, CSS files, and style-related Web control property settings that can be applied to a page at runtime.</span></span> <span data-ttu-id="e1921-180">主题是如果你的站点布局各不相同，这是仅在显示的图像和由其 CSS 规则的方式。</span><span class="sxs-lookup"><span data-stu-id="e1921-180">Themes are the way to go if your site's layouts differ only in the images displayed and by their CSS rules.</span></span> <span data-ttu-id="e1921-181">如果布局有所不同更大体上，例如使用不同的 Web 控件或具有完全不同的布局，你将需要使用单独的主控页。</span><span class="sxs-lookup"><span data-stu-id="e1921-181">If the layouts differ more substantially, such as using different Web controls or having a radically different layout, then you will need to use separate master pages.</span></span> <span data-ttu-id="e1921-182">在本教程末尾的有关主题的详细信息，请查阅其他阅读材料部分。</span><span class="sxs-lookup"><span data-stu-id="e1921-182">Consult the Further Reading section at the end of this tutorial for more information on Themes.</span></span>


<span data-ttu-id="e1921-183">[![我们内容页现在可以使用新的外观和感觉](specifying-the-master-page-programmatically-cs/_static/image11.png)](specifying-the-master-page-programmatically-cs/_static/image10.png)</span><span class="sxs-lookup"><span data-stu-id="e1921-183">[![Our Content Pages Can Now Use a New Look and Feel](specifying-the-master-page-programmatically-cs/_static/image11.png)](specifying-the-master-page-programmatically-cs/_static/image10.png)</span></span>

<span data-ttu-id="e1921-184">**图 04**： 我们内容页现在可以使用新的外观和感觉 ([单击以查看实际尺寸的图像](specifying-the-master-page-programmatically-cs/_static/image12.png))</span><span class="sxs-lookup"><span data-stu-id="e1921-184">**Figure 04**: Our Content Pages Can Now Use a New Look and Feel ([Click to view full-size image](specifying-the-master-page-programmatically-cs/_static/image12.png))</span></span>


<span data-ttu-id="e1921-185">当 fused master 和内容页的标记时，`MasterPage`类检查，以确保每个内容控件在内容页中的引用在母版页中的 ContentPlaceHolder。</span><span class="sxs-lookup"><span data-stu-id="e1921-185">When the master and content pages' markup are fused, the `MasterPage` class checks to ensure that every Content control in the content page references a ContentPlaceHolder in the master page.</span></span> <span data-ttu-id="e1921-186">如果找到了引用不存在 ContentPlaceHolder 内容控件，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="e1921-186">An exception is thrown if a Content control that references a non-existent ContentPlaceHolder is found.</span></span> <span data-ttu-id="e1921-187">换而言之，它是命令性主控页分配给内容页具有 ContentPlaceHolder，每个内容控件在内容页中的。</span><span class="sxs-lookup"><span data-stu-id="e1921-187">In other words, it is imperative that the master page being assigned to the content page have a ContentPlaceHolder for each Content control in the content page.</span></span>

<span data-ttu-id="e1921-188">`Site.master`母版页包括四个 ContentPlaceHolder 控件：</span><span class="sxs-lookup"><span data-stu-id="e1921-188">The `Site.master` master page includes four ContentPlaceHolder controls:</span></span>

- `head`
- `MainContent`
- `QuickLoginUI`
- `LeftColumnContent`

<span data-ttu-id="e1921-189">一些我们的网站中的内容页包括只是一个或两个内容控件;其他每个可用 ContentPlaceHolders 包括内容控件。</span><span class="sxs-lookup"><span data-stu-id="e1921-189">Some of the content pages in our website include just one or two Content controls; others include a Content control for each of the available ContentPlaceHolders.</span></span> <span data-ttu-id="e1921-190">如果我们新的母版页 (`Alternate.master`) 可能曾分配给具有内容控件中 ContentPlaceHolders 的所有这些内容页`Site.master`然后很重要，`Alternate.master`还包括与相同ContentPlaceHolder控制`Site.master`.</span><span class="sxs-lookup"><span data-stu-id="e1921-190">If our new master page (`Alternate.master`) may ever be assigned to those content pages that have Content controls for all of the ContentPlaceHolders in `Site.master` then it is essential that `Alternate.master` also include the same ContentPlaceHolder controls as `Site.master`.</span></span>

<span data-ttu-id="e1921-191">若要获取你`Alternate.master`母版页，看起来像要挖掘 （请参见图 4），请首先定义中的主控页的样式`AlternateStyles.css`样式表。</span><span class="sxs-lookup"><span data-stu-id="e1921-191">To get your `Alternate.master` master page to look similar to mine (see Figure 4), start by defining the master page's styles in the `AlternateStyles.css` style sheet.</span></span> <span data-ttu-id="e1921-192">添加到以下规则`AlternateStyles.css`:</span><span class="sxs-lookup"><span data-stu-id="e1921-192">Add the following rules into `AlternateStyles.css`:</span></span>


[!code-css[Main](specifying-the-master-page-programmatically-cs/samples/sample5.css)]

<span data-ttu-id="e1921-193">接下来，添加到以下的声明性标记`Alternate.master`。</span><span class="sxs-lookup"><span data-stu-id="e1921-193">Next, add the following declarative markup to `Alternate.master`.</span></span> <span data-ttu-id="e1921-194">如你所见，`Alternate.master`包含具有相同的四个 ContentPlaceHolder 控件`ID`值中的 ContentPlaceHolder 控件作为`Site.master`。</span><span class="sxs-lookup"><span data-stu-id="e1921-194">As you can see, `Alternate.master` contains four ContentPlaceHolder controls with the same `ID` values as the ContentPlaceHolder controls in `Site.master`.</span></span> <span data-ttu-id="e1921-195">此外，它包括 ScriptManager 控件，我们的网站中使用 ASP.NET AJAX 框架这些页才需要。</span><span class="sxs-lookup"><span data-stu-id="e1921-195">Moreover, it includes a ScriptManager control, which is necessary for those pages in our website that use the ASP.NET AJAX framework.</span></span>


[!code-aspx[Main](specifying-the-master-page-programmatically-cs/samples/sample6.aspx)]

### <a name="testing-the-new-master-page"></a><span data-ttu-id="e1921-196">测试新母版页</span><span class="sxs-lookup"><span data-stu-id="e1921-196">Testing the New Master Page</span></span>

<span data-ttu-id="e1921-197">若要测试此新的母版页更新`BasePage`类的`OnPreInit`方法，以便`MasterPageFile`属性分配值"~ / Alternate.maser"，然后访问该网站。</span><span class="sxs-lookup"><span data-stu-id="e1921-197">To test this new master page update the `BasePage` class's `OnPreInit` method so that the `MasterPageFile` property is assigned the value "~/Alternate.maser" and then visit the website.</span></span> <span data-ttu-id="e1921-198">每一页应正常情况下，除了两个函数：`~/Admin/AddProduct.aspx`和`~/Admin/Products.aspx`。</span><span class="sxs-lookup"><span data-stu-id="e1921-198">Every page should function without error except for two: `~/Admin/AddProduct.aspx` and `~/Admin/Products.aspx`.</span></span> <span data-ttu-id="e1921-199">在说明如何向中添加产品`~/Admin/AddProduct.aspx`导致`NullReferenceException`从尝试设置主控页的代码行`GridMessageText`属性。</span><span class="sxs-lookup"><span data-stu-id="e1921-199">Adding a product to the DetailsView in `~/Admin/AddProduct.aspx` results in a `NullReferenceException` from the line of code that attempts to set the master page's `GridMessageText` property.</span></span> <span data-ttu-id="e1921-200">当来访`~/Admin/Products.aspx``InvalidCastException`会在页面加载并显示消息上引发:"找不到类型的对象强制转换 ASP.alternate\_master 类型 ASP.site\_master。"</span><span class="sxs-lookup"><span data-stu-id="e1921-200">When visiting `~/Admin/Products.aspx` an `InvalidCastException` is thrown on page load with the message: "Unable to cast object of type 'ASP.alternate\_master' to type 'ASP.site\_master'."</span></span>

<span data-ttu-id="e1921-201">发生这些错误是因为`Site.master`代码隐藏类包括公共事件、 属性和方法中未定义`Alternate.master`。</span><span class="sxs-lookup"><span data-stu-id="e1921-201">These errors occur because the `Site.master` code-behind class includes public events, properties, and methods that are not defined in `Alternate.master`.</span></span> <span data-ttu-id="e1921-202">这些两个页面的标记部分有`@MasterType`引用的指令`Site.master`母版页。</span><span class="sxs-lookup"><span data-stu-id="e1921-202">The markup portion of these two pages have a `@MasterType` directive that references the `Site.master` master page.</span></span>


[!code-aspx[Main](specifying-the-master-page-programmatically-cs/samples/sample7.aspx)]

<span data-ttu-id="e1921-203">此外，说明的`ItemInserted`中的事件处理程序`~/Admin/AddProduct.aspx`包括将强制转换松散类型的代码`Page.Master`类型的对象属性`Site`。</span><span class="sxs-lookup"><span data-stu-id="e1921-203">Also, the DetailsView's `ItemInserted` event handler in `~/Admin/AddProduct.aspx` includes code that casts the loosely-typed `Page.Master` property to an object of type `Site`.</span></span> <span data-ttu-id="e1921-204">`@MasterType`指令 （使用这种方式） 和中的转换`ItemInserted`事件处理程序紧密标`~/Admin/AddProduct.aspx`和`~/Admin/Products.aspx`到页`Site.master`母版页。</span><span class="sxs-lookup"><span data-stu-id="e1921-204">The `@MasterType` directive (used this way) and the cast in the `ItemInserted` event handler tightly couples the `~/Admin/AddProduct.aspx` and `~/Admin/Products.aspx` pages to the `Site.master` master page.</span></span>

<span data-ttu-id="e1921-205">若要中断，可以有此紧密耦合`Site.master`和`Alternate.master`派生自公共基类，它包含的公共成员的定义。</span><span class="sxs-lookup"><span data-stu-id="e1921-205">To break this tight coupling we can have `Site.master` and `Alternate.master` derive from a common base class that contains definitions for the public members.</span></span> <span data-ttu-id="e1921-206">接下来，我们可以更新`@MasterType`指令以引用此通用的基类型。</span><span class="sxs-lookup"><span data-stu-id="e1921-206">Following that, we can update the `@MasterType` directive to reference this common base type.</span></span>

### <a name="creating-a-custom-base-master-page-class"></a><span data-ttu-id="e1921-207">创建自定义基本 Master 页类</span><span class="sxs-lookup"><span data-stu-id="e1921-207">Creating a Custom Base Master Page Class</span></span>

<span data-ttu-id="e1921-208">添加新的类文件与`App_Code`文件夹名为`BaseMasterPage.cs`，并将其派生自`System.Web.UI.MasterPage`。</span><span class="sxs-lookup"><span data-stu-id="e1921-208">Add a new class file to the `App_Code` folder named `BaseMasterPage.cs` and have it derive from `System.Web.UI.MasterPage`.</span></span> <span data-ttu-id="e1921-209">我们需要定义`RefreshRecentProductsGrid`方法和`GridMessageText`中的属性`BaseMasterPage`，但我们不能只需将它们移动存在从`Site.master`因为这些成员使用特定于的 Web 控件的工作`Site.master`母版页 ( `RecentProducts`GridView 和`GridMessage`标签)。</span><span class="sxs-lookup"><span data-stu-id="e1921-209">We need to define the `RefreshRecentProductsGrid` method and the `GridMessageText` property in `BaseMasterPage`, but we can't simply move them there from `Site.master` because these members work with Web controls that are specific to the `Site.master` master page (the `RecentProducts` GridView and `GridMessage` Label).</span></span>

<span data-ttu-id="e1921-210">我们需要做什么是配置`BaseMasterPage`这些成员，定义，但由实际实现的方式`BaseMasterPage`的派生类 (`Site.master`和`Alternate.master`)。</span><span class="sxs-lookup"><span data-stu-id="e1921-210">What we need to do is configure `BaseMasterPage` in such a way that these members are defined there, but are actually implemented by `BaseMasterPage`'s derived classes (`Site.master` and `Alternate.master`).</span></span> <span data-ttu-id="e1921-211">这种类型的继承可通过将标记的类并为其成员`abstract`。</span><span class="sxs-lookup"><span data-stu-id="e1921-211">This type of inheritance is possible by marking the class and its members as `abstract`.</span></span> <span data-ttu-id="e1921-212">简单地说，添加`abstract`到这两个成员的关键字宣布`BaseMasterPage`尚未实现`RefreshRecentProductsGrid`和`GridMessageText`，但该及其派生的类将。</span><span class="sxs-lookup"><span data-stu-id="e1921-212">In short, adding the `abstract` keyword to these two members announces that `BaseMasterPage` hasn't implemented `RefreshRecentProductsGrid` and `GridMessageText`, but that its derived classes will.</span></span>

<span data-ttu-id="e1921-213">我们还需要定义`PricesDoubled`中的事件`BaseMasterPage`通过并提供了一种方法来引发事件的派生类。</span><span class="sxs-lookup"><span data-stu-id="e1921-213">We also need to define the `PricesDoubled` event in `BaseMasterPage` and provide a means by the derived classes to raise the event.</span></span> <span data-ttu-id="e1921-214">.NET Framework 中用于促进此行为的模式是以基类中创建的公共事件，添加一个受保护`virtual`方法名为`OnEventName`。</span><span class="sxs-lookup"><span data-stu-id="e1921-214">The pattern used in the .NET Framework to facilitate this behavior is to create a public event in the base class and add a protected, `virtual` method named `OnEventName`.</span></span> <span data-ttu-id="e1921-215">派生的类可以然后调用此方法来引发事件，或可重写它之前或之后引发事件时，才执行代码。</span><span class="sxs-lookup"><span data-stu-id="e1921-215">Derived classes can then call this method to raise the event or can override it to execute code immediately before or after the event is raised.</span></span>

<span data-ttu-id="e1921-216">更新你`BaseMasterPage`类以使其包含以下代码：</span><span class="sxs-lookup"><span data-stu-id="e1921-216">Update your `BaseMasterPage` class so that it contains the following code:</span></span>


[!code-csharp[Main](specifying-the-master-page-programmatically-cs/samples/sample8.cs)]

<span data-ttu-id="e1921-217">接下来，请转到`Site.master`代码隐藏类，并将其派生自`BaseMasterPage`。</span><span class="sxs-lookup"><span data-stu-id="e1921-217">Next, go to the `Site.master` code-behind class and have it derive from `BaseMasterPage`.</span></span> <span data-ttu-id="e1921-218">因为`BaseMasterPage`是`abstract`我们需要重写那些`abstract`中的成员此处`Site.master`。</span><span class="sxs-lookup"><span data-stu-id="e1921-218">Because `BaseMasterPage` is `abstract` we need to override those `abstract` members here in `Site.master`.</span></span> <span data-ttu-id="e1921-219">添加`override`关键字的方法和属性定义。</span><span class="sxs-lookup"><span data-stu-id="e1921-219">Add the `override` keyword to the method and property definitions.</span></span> <span data-ttu-id="e1921-220">此外更新引发的代码`PricesDoubled`中的事件`DoublePrice`按钮的`Click`通过调用基类的事件处理程序`OnPricesDoubled`方法。</span><span class="sxs-lookup"><span data-stu-id="e1921-220">Also update the code that raises the `PricesDoubled` event in the `DoublePrice` Button's `Click` event handler with a call to the base class's `OnPricesDoubled` method.</span></span>

<span data-ttu-id="e1921-221">这些修改后`Site.master`代码隐藏类应包含以下代码：</span><span class="sxs-lookup"><span data-stu-id="e1921-221">After these modifications the `Site.master` code-behind class should contain the following code:</span></span>


[!code-csharp[Main](specifying-the-master-page-programmatically-cs/samples/sample9.cs)]

<span data-ttu-id="e1921-222">我们还需要更新`Alternate.master`的代码隐藏类以派生自`BaseMasterPage`并重写两个`abstract`成员。</span><span class="sxs-lookup"><span data-stu-id="e1921-222">We also need to update `Alternate.master`'s code-behind class to derive from `BaseMasterPage` and override the two `abstract` members.</span></span> <span data-ttu-id="e1921-223">但是，由于`Alternate.master`不包含一个 GridView，最新的产品和新产品后显示一条消息的标签都添加到数据库的列表，这些方法不需要执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="e1921-223">But because `Alternate.master` does not contain a GridView that lists the most recent products nor a Label that displays a message after a new product is added to the database, these methods do not need to do anything.</span></span>


[!code-csharp[Main](specifying-the-master-page-programmatically-cs/samples/sample10.cs)]

### <a name="referencing-the-base-master-page-class"></a><span data-ttu-id="e1921-224">引用基 Master 页类</span><span class="sxs-lookup"><span data-stu-id="e1921-224">Referencing the Base Master Page Class</span></span>

<span data-ttu-id="e1921-225">现在，我们已完成`BaseMasterPage`类并且没有将其扩展我们两个母版页，我们最后一步是更新`~/Admin/AddProduct.aspx`和`~/Admin/Products.aspx`页来指代此通用类型。</span><span class="sxs-lookup"><span data-stu-id="e1921-225">Now that we have completed the `BaseMasterPage` class and have our two master pages extending it, our final step is to update the `~/Admin/AddProduct.aspx` and `~/Admin/Products.aspx` pages to refer to this common type.</span></span> <span data-ttu-id="e1921-226">通过更改启动`@MasterType`指令从这两个页中：</span><span class="sxs-lookup"><span data-stu-id="e1921-226">Start by changing the `@MasterType` directive in both pages from:</span></span>


[!code-aspx[Main](specifying-the-master-page-programmatically-cs/samples/sample11.aspx)]

<span data-ttu-id="e1921-227">到:</span><span class="sxs-lookup"><span data-stu-id="e1921-227">To:</span></span>


[!code-aspx[Main](specifying-the-master-page-programmatically-cs/samples/sample12.aspx)]

<span data-ttu-id="e1921-228">而不是引用文件路径，`@MasterType`属性现在引用的基类型 (`BaseMasterPage`)。</span><span class="sxs-lookup"><span data-stu-id="e1921-228">Rather than referencing a file path, the `@MasterType` property now references the base type (`BaseMasterPage`).</span></span> <span data-ttu-id="e1921-229">因此，对强类型`Master`在这两个页的代码隐藏类中使用的属性现在是类型的`BaseMasterPage`(而不是类型`Site`)。</span><span class="sxs-lookup"><span data-stu-id="e1921-229">Consequently, the strongly-typed `Master` property used in both pages' code-behind classes is now of type `BaseMasterPage` (instead of type `Site`).</span></span> <span data-ttu-id="e1921-230">进行此更改后就地重新访问`~/Admin/Products.aspx`。</span><span class="sxs-lookup"><span data-stu-id="e1921-230">With this change in place revisit `~/Admin/Products.aspx`.</span></span> <span data-ttu-id="e1921-231">以前，这导致强制转换错误因为页面已配置为使用`Alternate.master`主页上，但`@MasterType`指令引用`Site.master`文件。</span><span class="sxs-lookup"><span data-stu-id="e1921-231">Previously, this resulted in a casting error because the page is configured to use the `Alternate.master` master page, but the `@MasterType` directive referenced the `Site.master` file.</span></span> <span data-ttu-id="e1921-232">但现在没有错误呈现页面。</span><span class="sxs-lookup"><span data-stu-id="e1921-232">But now the page renders without error.</span></span> <span data-ttu-id="e1921-233">这是因为`Alternate.master`母版页可以强制转换为类型的对象`BaseMasterPage`（因为它进行扩展）。</span><span class="sxs-lookup"><span data-stu-id="e1921-233">This is because the `Alternate.master` master page can be cast to an object of type `BaseMasterPage` (since it extends it).</span></span>

<span data-ttu-id="e1921-234">没有需要在中所做的一个小更改`~/Admin/AddProduct.aspx`。</span><span class="sxs-lookup"><span data-stu-id="e1921-234">There's one small change that needs to be made in `~/Admin/AddProduct.aspx`.</span></span> <span data-ttu-id="e1921-235">说明如何控制`ItemInserted`事件处理程序使用这两个强类型`Master`属性和松散类型`Page.Master`属性。</span><span class="sxs-lookup"><span data-stu-id="e1921-235">The DetailsView control's `ItemInserted` event handler uses both the strongly-typed `Master` property and the loosely-typed `Page.Master` property.</span></span> <span data-ttu-id="e1921-236">我们解决的强类型的引用，我们更新时`@MasterType`指令，但我们仍需要更新的松散类型化的引用。</span><span class="sxs-lookup"><span data-stu-id="e1921-236">We fixed the strongly-typed reference when we updated the `@MasterType` directive, but we still need to update the loosely-typed reference.</span></span> <span data-ttu-id="e1921-237">将以下代码行：</span><span class="sxs-lookup"><span data-stu-id="e1921-237">Replace the following line of code:</span></span>


[!code-csharp[Main](specifying-the-master-page-programmatically-cs/samples/sample13.cs)]

<span data-ttu-id="e1921-238">使用以下内容，这会强制`Page.Master`为基类型：</span><span class="sxs-lookup"><span data-stu-id="e1921-238">With the following, which casts `Page.Master` to the base type:</span></span>


[!code-csharp[Main](specifying-the-master-page-programmatically-cs/samples/sample14.cs)]

## <a name="step-4-determining-what-master-page-to-bind-to-the-content-pages"></a><span data-ttu-id="e1921-239">步骤 4： 确定哪些母版页绑定到内容页</span><span class="sxs-lookup"><span data-stu-id="e1921-239">Step 4: Determining What Master Page to Bind to the Content Pages</span></span>

<span data-ttu-id="e1921-240">我们`BasePage`类当前设置所有内容页的`MasterPageFile`属性设置为在页面生命周期的 PreInit 阶段硬编码的值。</span><span class="sxs-lookup"><span data-stu-id="e1921-240">Our `BasePage` class currently sets all content pages' `MasterPageFile` properties to a hard-coded value in the PreInit stage of the page lifecycle.</span></span> <span data-ttu-id="e1921-241">我们可以更新此代码，以根据某些外部因素的主控页。</span><span class="sxs-lookup"><span data-stu-id="e1921-241">We can update this code to base the master page on some external factor.</span></span> <span data-ttu-id="e1921-242">可能要加载的主页面取决于当前登录用户的首选项。</span><span class="sxs-lookup"><span data-stu-id="e1921-242">Perhaps the master page to load depends on the preferences of the currently logged on user.</span></span> <span data-ttu-id="e1921-243">在这种情况下，我们将需要在中编写代码`OnPreInit`中的方法`BasePage`，查找当前正在访问用户的母版页首选项。</span><span class="sxs-lookup"><span data-stu-id="e1921-243">In that case, we'd need to write code in the `OnPreInit` method in `BasePage` that looks up the currently visiting user's master page preferences.</span></span>

<span data-ttu-id="e1921-244">让我们创建一个网页，允许用户选择的主控页后，可以使用-`Site.master`或`Alternate.master`-并将此选择保存的会话变量中。</span><span class="sxs-lookup"><span data-stu-id="e1921-244">Let's create a web page that allows the user to choose which master page to use - `Site.master` or `Alternate.master` - and save this choice in a Session variable.</span></span> <span data-ttu-id="e1921-245">通过在名为的根目录中创建新的 web 页启动`ChooseMasterPage.aspx`。</span><span class="sxs-lookup"><span data-stu-id="e1921-245">Start by creating a new web page in the root directory named `ChooseMasterPage.aspx`.</span></span> <span data-ttu-id="e1921-246">创建此页 （或任何其他内容页之后） 时无需将其绑定到母板页中，因为主控页以编程方式设置`BasePage`。</span><span class="sxs-lookup"><span data-stu-id="e1921-246">When creating this page (or any other content pages henceforth) you don't need to bind it to a master page because the master page is set programmatically in `BasePage`.</span></span> <span data-ttu-id="e1921-247">但是，如果你不会绑定的新页到母版页然后新页面的默认声明性标记包含 Web 窗体和母版页由提供的其他内容。</span><span class="sxs-lookup"><span data-stu-id="e1921-247">However, if you do not bind the new page to a master page then the new page's default declarative markup contains a Web Form and other content supplied by the master page.</span></span> <span data-ttu-id="e1921-248">你将需要手动将此标记替换为适当的内容控件。</span><span class="sxs-lookup"><span data-stu-id="e1921-248">You'll need to manually replace this markup with the appropriate Content controls.</span></span> <span data-ttu-id="e1921-249">为此，我发现更轻松地将新的 ASP.NET 页绑定到母版页。</span><span class="sxs-lookup"><span data-stu-id="e1921-249">For that reason, I find it easier to bind the new ASP.NET page to a master page.</span></span>

> [!NOTE]
> <span data-ttu-id="e1921-250">因为`Site.master`和`Alternate.master`具有组相同的 ContentPlaceHolder 控件并不重要时创建新的内容页选择哪些母版页。</span><span class="sxs-lookup"><span data-stu-id="e1921-250">Because `Site.master` and `Alternate.master` have the same set of ContentPlaceHolder controls it doesn't matter what master page you choose when creating the new content page.</span></span> <span data-ttu-id="e1921-251">为了保持一致性，建议使用`Site.master`。</span><span class="sxs-lookup"><span data-stu-id="e1921-251">For consistency, I'd suggest using `Site.master`.</span></span>


<span data-ttu-id="e1921-252">[![将新的内容页添加到网站](specifying-the-master-page-programmatically-cs/_static/image14.png)](specifying-the-master-page-programmatically-cs/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="e1921-252">[![Add a New Content Page to the Website](specifying-the-master-page-programmatically-cs/_static/image14.png)](specifying-the-master-page-programmatically-cs/_static/image13.png)</span></span>

<span data-ttu-id="e1921-253">**图 05**： 向网站添加新的内容页 ([单击以查看实际尺寸的图像](specifying-the-master-page-programmatically-cs/_static/image15.png))</span><span class="sxs-lookup"><span data-stu-id="e1921-253">**Figure 05**: Add a New Content Page to the Website ([Click to view full-size image](specifying-the-master-page-programmatically-cs/_static/image15.png))</span></span>


<span data-ttu-id="e1921-254">更新`Web.sitemap`文件以包含本课程的适当的项。</span><span class="sxs-lookup"><span data-stu-id="e1921-254">Update the `Web.sitemap` file to include an entry for this lesson.</span></span> <span data-ttu-id="e1921-255">添加以下标记下的`<siteMapNode>`母版页和 ASP.NET AJAX 课后生成：</span><span class="sxs-lookup"><span data-stu-id="e1921-255">Add the following markup beneath the `<siteMapNode>` for the Master Pages and ASP.NET AJAX lesson:</span></span>


[!code-xml[Main](specifying-the-master-page-programmatically-cs/samples/sample15.xml)]

<span data-ttu-id="e1921-256">然后再添加任何内容分发至`ChooseMasterPage.aspx`页面需要一段时间来更新页的代码隐藏类，使它派生自`BasePage`(而非`System.Web.UI.Page`)。</span><span class="sxs-lookup"><span data-stu-id="e1921-256">Before adding any content to the `ChooseMasterPage.aspx` page take a moment to update the page's code-behind class so that it derives from `BasePage` (rather than `System.Web.UI.Page`).</span></span> <span data-ttu-id="e1921-257">接下来，将 DropDownList 控件添加到页，设置其`ID`属性`MasterPageChoice`，并添加具有两个 ListItems`Text`的值"~ / Site.master"和"~ / Alternate.master"。</span><span class="sxs-lookup"><span data-stu-id="e1921-257">Next, add a DropDownList control to the page, set its `ID` property to `MasterPageChoice`, and add two ListItems with the `Text` values of "~/Site.master" and "~/Alternate.master".</span></span>

<span data-ttu-id="e1921-258">向页面添加按钮 Web 控件并设置其`ID`和`Text`属性设置为`SaveLayout`和"保存布局选择"，分别。</span><span class="sxs-lookup"><span data-stu-id="e1921-258">Add a Button Web control to the page and set its `ID` and `Text` properties to `SaveLayout` and "Save Layout Choice", respectively.</span></span> <span data-ttu-id="e1921-259">此时页面的声明性标记应类似以下：</span><span class="sxs-lookup"><span data-stu-id="e1921-259">At this point your page's declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](specifying-the-master-page-programmatically-cs/samples/sample16.aspx)]

<span data-ttu-id="e1921-260">当首次访问页时，我们需要显示用户的当前所选的母版页选择。</span><span class="sxs-lookup"><span data-stu-id="e1921-260">When the page is first visited we need to display the user's currently selected master page choice.</span></span> <span data-ttu-id="e1921-261">创建`Page_Load`事件处理程序并添加以下代码：</span><span class="sxs-lookup"><span data-stu-id="e1921-261">Create a `Page_Load` event handler and add the following code:</span></span>


[!code-csharp[Main](specifying-the-master-page-programmatically-cs/samples/sample17.cs)]

<span data-ttu-id="e1921-262">上面的代码执行仅在第一次的页访问 （而不在后续回发）。</span><span class="sxs-lookup"><span data-stu-id="e1921-262">The above code executes only on the first page visit (and not on subsequent postbacks).</span></span> <span data-ttu-id="e1921-263">它首先检查是否会话变量`MyMasterPage`存在。</span><span class="sxs-lookup"><span data-stu-id="e1921-263">It first checks to see if the Session variable `MyMasterPage` exists.</span></span> <span data-ttu-id="e1921-264">如果是这样，它尝试查找列表中的项匹配`MasterPageChoice`DropDownList。</span><span class="sxs-lookup"><span data-stu-id="e1921-264">If it does, it attempts to find the matching ListItem in the `MasterPageChoice` DropDownList.</span></span> <span data-ttu-id="e1921-265">如果找到匹配的 ListItem，则其`Selected`属性设置为`true`。</span><span class="sxs-lookup"><span data-stu-id="e1921-265">If a matching ListItem is found, its `Selected` property is set to `true`.</span></span>

<span data-ttu-id="e1921-266">我们还需要将保存到的用户的选择的代码`MyMasterPage`会话变量。</span><span class="sxs-lookup"><span data-stu-id="e1921-266">We also need code that saves the user's choice into the `MyMasterPage` Session variable.</span></span> <span data-ttu-id="e1921-267">创建的事件处理程序`SaveLayout`按钮的`Click`事件并添加以下代码：</span><span class="sxs-lookup"><span data-stu-id="e1921-267">Create an event handler for the `SaveLayout` Button's `Click` event and add the following code:</span></span>


[!code-csharp[Main](specifying-the-master-page-programmatically-cs/samples/sample18.cs)]

> [!NOTE]
> <span data-ttu-id="e1921-268">按时间`Click`事件处理程序执行回发时，主控页已被选择。</span><span class="sxs-lookup"><span data-stu-id="e1921-268">By the time the `Click` event handler executes on postback, the master page has already been selected.</span></span> <span data-ttu-id="e1921-269">因此，用户的下拉列表中选择不会生效直到下一个页面访问。</span><span class="sxs-lookup"><span data-stu-id="e1921-269">Therefore, the user's drop-down list selection won't be in effect until the next page visit.</span></span> <span data-ttu-id="e1921-270">`Response.Redirect`强制浏览器将重新请求`ChooseMasterPage.aspx`。</span><span class="sxs-lookup"><span data-stu-id="e1921-270">The `Response.Redirect` forces the browser to re-request `ChooseMasterPage.aspx`.</span></span>


<span data-ttu-id="e1921-271">与`ChooseMasterPage.aspx`完成的页上，我们最后一项任务是让`BasePage`分配`MasterPageFile`属性基于的值`MyMasterPage`会话变量。</span><span class="sxs-lookup"><span data-stu-id="e1921-271">With the `ChooseMasterPage.aspx` page complete, our final task is to have `BasePage` assign the `MasterPageFile` property based on the value of the `MyMasterPage` Session variable.</span></span> <span data-ttu-id="e1921-272">如果未设置会话变量具有`BasePage`默认为`Site.master`。</span><span class="sxs-lookup"><span data-stu-id="e1921-272">If the Session variable is not set have `BasePage` default to `Site.master`.</span></span>


[!code-csharp[Main](specifying-the-master-page-programmatically-cs/samples/sample19.cs)]

> [!NOTE]
> <span data-ttu-id="e1921-273">我已分配的代码将移动`Page`对象的`MasterPageFile`外的属性`OnPreInit`事件处理程序，并放入两个不同方法。</span><span class="sxs-lookup"><span data-stu-id="e1921-273">I moved the code that assigns the `Page` object's `MasterPageFile` property out of the `OnPreInit` event handler and into two separate methods.</span></span> <span data-ttu-id="e1921-274">此第一种方法， `SetMasterPageFile`，将分配`MasterPageFile`到第二种方法，返回的值的属性`GetMasterPageFileFromSession`。</span><span class="sxs-lookup"><span data-stu-id="e1921-274">This first method, `SetMasterPageFile`, assigns the `MasterPageFile` property to the value returned by the second method, `GetMasterPageFileFromSession`.</span></span> <span data-ttu-id="e1921-275">我进行了`SetMasterPageFile`方法`virtual`以便将来的课程可扩展`BasePage`可以选择重写以使其实现自定义逻辑，如果需要。</span><span class="sxs-lookup"><span data-stu-id="e1921-275">I made the `SetMasterPageFile` method `virtual` so that future classes that extend `BasePage` can optionally override it to implement custom logic, if needed.</span></span> <span data-ttu-id="e1921-276">我们将看到举例说明重写`BasePage`的`SetMasterPageFile`下一教程中的属性。</span><span class="sxs-lookup"><span data-stu-id="e1921-276">We'll see an example of overriding `BasePage`'s `SetMasterPageFile` property in the next tutorial.</span></span>


<span data-ttu-id="e1921-277">使用此代码中的位置，请访问`ChooseMasterPage.aspx`页。</span><span class="sxs-lookup"><span data-stu-id="e1921-277">With this code in place, visit the `ChooseMasterPage.aspx` page.</span></span> <span data-ttu-id="e1921-278">最初，`Site.master`母版页是所选 （请参阅图 6），但用户均可选择不同的母版页，从下拉列表。</span><span class="sxs-lookup"><span data-stu-id="e1921-278">Initially, the `Site.master` master page is selected (see Figure 6), but the user can pick a different master page from the drop-down list.</span></span>


<span data-ttu-id="e1921-279">[![内容页将显示使用 Site.master 母版页](specifying-the-master-page-programmatically-cs/_static/image17.png)](specifying-the-master-page-programmatically-cs/_static/image16.png)</span><span class="sxs-lookup"><span data-stu-id="e1921-279">[![Content Pages are Displayed Using the Site.master Master Page](specifying-the-master-page-programmatically-cs/_static/image17.png)](specifying-the-master-page-programmatically-cs/_static/image16.png)</span></span>

<span data-ttu-id="e1921-280">**图 06**： 内容页将显示使用`Site.master`母版页 ([单击以查看实际尺寸的图像](specifying-the-master-page-programmatically-cs/_static/image18.png))</span><span class="sxs-lookup"><span data-stu-id="e1921-280">**Figure 06**: Content Pages are Displayed Using the `Site.master` Master Page ([Click to view full-size image](specifying-the-master-page-programmatically-cs/_static/image18.png))</span></span>


<span data-ttu-id="e1921-281">[![内容页现在显示使用 Alternate.master 母版页](specifying-the-master-page-programmatically-cs/_static/image20.png)](specifying-the-master-page-programmatically-cs/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="e1921-281">[![Content Pages are Now Displayed Using the Alternate.master Master Page](specifying-the-master-page-programmatically-cs/_static/image20.png)](specifying-the-master-page-programmatically-cs/_static/image19.png)</span></span>

<span data-ttu-id="e1921-282">**图 07**： 内容页是现在显示使用`Alternate.master`母版页 ([单击以查看实际尺寸的图像](specifying-the-master-page-programmatically-cs/_static/image21.png))</span><span class="sxs-lookup"><span data-stu-id="e1921-282">**Figure 07**: Content Pages are Now Displayed Using the `Alternate.master` Master Page ([Click to view full-size image](specifying-the-master-page-programmatically-cs/_static/image21.png))</span></span>


## <a name="summary"></a><span data-ttu-id="e1921-283">摘要</span><span class="sxs-lookup"><span data-stu-id="e1921-283">Summary</span></span>

<span data-ttu-id="e1921-284">时访问内容页，其内容的控件使用其母版页 ContentPlaceHolder 控件融合。</span><span class="sxs-lookup"><span data-stu-id="e1921-284">When a content page is visited, its Content controls are fused with its master page's ContentPlaceHolder controls.</span></span> <span data-ttu-id="e1921-285">内容页的主控页由表示`Page`类的`MasterPageFile`属性，该值将赋给`@Page`指令的`MasterPageFile`在初始化阶段的属性。</span><span class="sxs-lookup"><span data-stu-id="e1921-285">The content page's master page is denoted by the `Page` class's `MasterPageFile` property, which is assigned to the `@Page` directive's `MasterPageFile` attribute during the Initialization stage.</span></span> <span data-ttu-id="e1921-286">与本教程介绍了，我们可以将值赋给`MasterPageFile`只要我们这样 PreInit 阶段结束之前的属性。</span><span class="sxs-lookup"><span data-stu-id="e1921-286">As this tutorial showed, we can assign a value to the `MasterPageFile` property as long as we do so before the end of the PreInit stage.</span></span> <span data-ttu-id="e1921-287">能够以编程方式指定主控页将打开用于更高级的方案，如动态绑定到外部因素所基于的母版页的内容页的门。</span><span class="sxs-lookup"><span data-stu-id="e1921-287">Being able to programmatically specify the master page opens the door for more advanced scenarios, such as dynamically binding a content page to a master page based on external factors.</span></span>

<span data-ttu-id="e1921-288">尽情享受编程 ！</span><span class="sxs-lookup"><span data-stu-id="e1921-288">Happy Programming!</span></span>

### <a name="further-reading"></a><span data-ttu-id="e1921-289">其他阅读材料</span><span class="sxs-lookup"><span data-stu-id="e1921-289">Further Reading</span></span>

<span data-ttu-id="e1921-290">在本教程中讨论的主题的详细信息，请参阅以下资源：</span><span class="sxs-lookup"><span data-stu-id="e1921-290">For more information on the topics discussed in this tutorial, refer to the following resources:</span></span>

- [<span data-ttu-id="e1921-291">ASP.NET 页面生命周期关系图</span><span class="sxs-lookup"><span data-stu-id="e1921-291">ASP.NET Page Lifecycle Diagram</span></span>](http://emanish.googlepages.com/Asp.Net2.0Lifecycle.PNG)
- [<span data-ttu-id="e1921-292">ASP.NET 页面生命周期概述</span><span class="sxs-lookup"><span data-stu-id="e1921-292">ASP.NET Page Lifecycle Overview</span></span>](https://msdn.microsoft.com/en-us/library/ms178472.aspx)
- [<span data-ttu-id="e1921-293">ASP.NET 主题和皮肤概述</span><span class="sxs-lookup"><span data-stu-id="e1921-293">ASP.NET Themes and Skins Overview</span></span>](https://msdn.microsoft.com/en-us/library/ykzx33wh.aspx)
- [<span data-ttu-id="e1921-294">母版页： 提示、 技巧和陷阱</span><span class="sxs-lookup"><span data-stu-id="e1921-294">Master Pages: Tips, Tricks, and Traps</span></span>](http://www.odetocode.com/articles/450.aspx)
- [<span data-ttu-id="e1921-295">在 ASP.NET 中的主题</span><span class="sxs-lookup"><span data-stu-id="e1921-295">Themes in ASP.NET</span></span>](http://www.odetocode.com/articles/423.aspx)

### <a name="about-the-author"></a><span data-ttu-id="e1921-296">关于作者</span><span class="sxs-lookup"><span data-stu-id="e1921-296">About the Author</span></span>

<span data-ttu-id="e1921-297">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，作者的多个 ASP/ASP.NET 丛书和 4GuysFromRolla.com 创始人，具有已使用 Microsoft Web 技术自 1998 年。</span><span class="sxs-lookup"><span data-stu-id="e1921-297">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of multiple ASP/ASP.NET books and founder of 4GuysFromRolla.com, has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="e1921-298">Scott 的作用是作为独立的顾问、 培训师和编写器。</span><span class="sxs-lookup"><span data-stu-id="e1921-298">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="e1921-299">最新书籍是[ *Sam 教授自己 ASP.NET 3.5 24 小时内*](https://www.amazon.com/exec/obidos/ASIN/0672329972/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="e1921-299">His latest book is [*Sams Teach Yourself ASP.NET 3.5 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672329972/4guysfromrollaco).</span></span> <span data-ttu-id="e1921-300">可以在达到 Scott [ mitchell@4GuysFromRolla.com ](mailto:mitchell@4GuysFromRolla.com)或通过在其博客地址[http://ScottOnWriting.NET](http://scottonwriting.net/)。</span><span class="sxs-lookup"><span data-stu-id="e1921-300">Scott can be reached at [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com) or via his blog at [http://ScottOnWriting.NET](http://scottonwriting.net/).</span></span>

### <a name="special-thanks-to"></a><span data-ttu-id="e1921-301">特别感谢</span><span class="sxs-lookup"><span data-stu-id="e1921-301">Special Thanks To</span></span>

<span data-ttu-id="e1921-302">本教程系列已由许多有用的审阅者评审。</span><span class="sxs-lookup"><span data-stu-id="e1921-302">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="e1921-303">本教程中的前导审阅者已 Suchi Banerjee。</span><span class="sxs-lookup"><span data-stu-id="e1921-303">Lead reviewer for this tutorial was Suchi Banerjee.</span></span> <span data-ttu-id="e1921-304">对感兴趣查看我即将到来的 MSDN 文章？</span><span class="sxs-lookup"><span data-stu-id="e1921-304">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="e1921-305">如果是这样，删除我一行[mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="e1921-305">If so, drop me a line at [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com)</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="e1921-306">[上一页](master-pages-and-asp-net-ajax-cs.md)
[下一页](nested-master-pages-cs.md)</span><span class="sxs-lookup"><span data-stu-id="e1921-306">[Previous](master-pages-and-asp-net-ajax-cs.md)
[Next](nested-master-pages-cs.md)</span></span>
