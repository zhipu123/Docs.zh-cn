---
uid: mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
title: "在 ASP.NET MVC 和 Web Pages XSRF/CSRF 预防 |Microsoft 文档"
author: Rick-Anderson
description: "跨站点请求伪造 （也称为 XSRF 或 CSRF） 是一种针对 web 托管的应用程序恶意网站凭此可以影响 interacti 攻击..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 03/14/2013
ms.topic: article
ms.assetid: aadc5fa4-8215-4fc7-afd5-bcd2ef879728
ms.technology: dotnet-mvc
ms.prod: .net-framework
msc.legacyurl: /mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
msc.type: authoredcontent
ms.openlocfilehash: 4ff4ed20d0768a48f8afb2deeb7cdb6b4c60b5bc
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/10/2017
---
<a name="xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages"></a><span data-ttu-id="1a880-103">在 ASP.NET MVC 和 Web Pages XSRF/CSRF 防护</span><span class="sxs-lookup"><span data-stu-id="1a880-103">XSRF/CSRF Prevention in ASP.NET MVC and Web Pages</span></span>
====================
<span data-ttu-id="1a880-104">通过[Rick Anderson](https://github.com/Rick-Anderson)</span><span class="sxs-lookup"><span data-stu-id="1a880-104">by [Rick Anderson](https://github.com/Rick-Anderson)</span></span>

> <span data-ttu-id="1a880-105">跨站点请求伪造 （也称为 XSRF 或 CSRF） 是针对恶意网站凭此可以影响客户端浏览器和受该浏览器信任的网站之间的交互的 web 托管的应用程序的攻击。</span><span class="sxs-lookup"><span data-stu-id="1a880-105">Cross-site request forgery (also known as XSRF or CSRF) is an attack against web-hosted applications whereby a malicious web site can influence the interaction between a client browser and a web site trusted by that browser.</span></span> <span data-ttu-id="1a880-106">因为 web 浏览器将发送到网站的自动与每个请求的身份验证令牌，这些攻击都可能。</span><span class="sxs-lookup"><span data-stu-id="1a880-106">These attacks are made possible because web browsers will send authentication tokens automatically with every request to a web site.</span></span> <span data-ttu-id="1a880-107">典型示例是身份验证 cookie，如 ASP。NET 的窗体身份验证票证。</span><span class="sxs-lookup"><span data-stu-id="1a880-107">The canonical example is an authentication cookie, such as ASP.NET's Forms Authentication ticket.</span></span> <span data-ttu-id="1a880-108">但是，使用任何持久身份验证 （如 Windows 身份验证、 Basic 等） 的网站可以受攻击目标。</span><span class="sxs-lookup"><span data-stu-id="1a880-108">However, web sites which use any persistent authentication mechanism (such as Windows Authentication, Basic, and so forth) can be targeted by these attacks.</span></span>
> 
> <span data-ttu-id="1a880-109">XSRF 攻击是不同于网络钓鱼攻击。</span><span class="sxs-lookup"><span data-stu-id="1a880-109">An XSRF attack is distinct from a phishing attack.</span></span> <span data-ttu-id="1a880-110">网络钓鱼攻击需要与受害者进行交互。</span><span class="sxs-lookup"><span data-stu-id="1a880-110">Phishing attacks require interaction from the victim.</span></span> <span data-ttu-id="1a880-111">在网络钓鱼攻击中，恶意网站将仿冒目标网站，并向攻击者提供敏感信息受到欺骗的受害者。</span><span class="sxs-lookup"><span data-stu-id="1a880-111">In a phishing attack, a malicious web site will mimic the target web site, and the victim is fooled into providing sensitive information to the attacker.</span></span> <span data-ttu-id="1a880-112">在 XSRF 攻击中，没有通常无需交互不必与受害者。</span><span class="sxs-lookup"><span data-stu-id="1a880-112">In an XSRF attack, there is often no interaction necessary from the victim.</span></span> <span data-ttu-id="1a880-113">相反，攻击者依赖于自动向目标网站发送所有相关 cookie 的浏览器。</span><span class="sxs-lookup"><span data-stu-id="1a880-113">Rather, the attacker is relying on the browser automatically sending all relevant cookies to the destination web site.</span></span>
> 
> <span data-ttu-id="1a880-114">有关详细信息，请参阅[打开 Web 应用程序安全项目](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF))。</span><span class="sxs-lookup"><span data-stu-id="1a880-114">For more information, see the [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span></span>


## <a name="anatomy-of-an-attack"></a><span data-ttu-id="1a880-115">攻击剖析</span><span class="sxs-lookup"><span data-stu-id="1a880-115">Anatomy of an attack</span></span>

<span data-ttu-id="1a880-116">若要指导 XSRF 攻击，请考虑想要执行一些联机银行事务的用户。</span><span class="sxs-lookup"><span data-stu-id="1a880-116">To walk through an XSRF attack, consider a user who wants to perform some online banking transactions.</span></span> <span data-ttu-id="1a880-117">此用户第一次访问 WoodgroveBank.com 和中，日志的位置响应标头将包含其身份验证 cookie:</span><span class="sxs-lookup"><span data-stu-id="1a880-117">This user first visits WoodgroveBank.com and logs in, at which point the response header will contain her authentication cookie:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample1.cmd)]

<span data-ttu-id="1a880-118">由于身份验证 cookie 的会话 cookie，它将自动清除浏览器时在浏览器进程退出。</span><span class="sxs-lookup"><span data-stu-id="1a880-118">Because the authentication cookie is a session cookie, it will be automatically cleared by the browser when the browser process exits.</span></span> <span data-ttu-id="1a880-119">但是，在此之前，浏览器将自动包括具有 WoodgroveBank.com 的每个请求 cookie。用户现在想要将 $1000 传输到另一个帐户，因此她填写银行站点上的表单和浏览器向服务器发出此请求：</span><span class="sxs-lookup"><span data-stu-id="1a880-119">However, until that time, the browser will automatically include the cookie with each request to WoodgroveBank.com. The user now wants to transfer $1000 to another account, so she fills out a form on the banking site, and the browser makes this request to the server:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample2.cmd)]

<span data-ttu-id="1a880-120">因为此操作具有副作用 （它将启动资金事务），已选择银行站点需要才能启动此操作的 HTTP POST。</span><span class="sxs-lookup"><span data-stu-id="1a880-120">Because this operation has a side effect (it initiates a monetary transaction), the banking site has chosen to require an HTTP POST in order to initiate this operation.</span></span> <span data-ttu-id="1a880-121">服务器读取请求的身份验证令牌、 查找当前用户的帐户数、 验证足够的资金存在，，然后启动到目标帐户事务。</span><span class="sxs-lookup"><span data-stu-id="1a880-121">The server reads the authentication token from the request, looks up the current user's account number, verifies that sufficient funds exist, and then initiates the transaction into the destination account.</span></span>

<span data-ttu-id="1a880-122">她联机银行完成后，用户导航离开银行站点并访问 web 上的其他位置。</span><span class="sxs-lookup"><span data-stu-id="1a880-122">Her online banking complete, the user navigates away from the banking site and visits other locations on the web.</span></span> <span data-ttu-id="1a880-123">其中一个 – fabrikam.com – 这些站点包括嵌入在页面上的以下标记&lt;iframe&gt;:</span><span class="sxs-lookup"><span data-stu-id="1a880-123">One of those sites – fabrikam.com – includes the following markup on a page embedded within an &lt;iframe&gt;:</span></span>

[!code-html[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample3.html)]

<span data-ttu-id="1a880-124">它会导致浏览器发出此请求：</span><span class="sxs-lookup"><span data-stu-id="1a880-124">Which then causes the browser to make this request:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample4.cmd)]

<span data-ttu-id="1a880-125">攻击者利用事实，用户可能仍具有有效的身份验证令牌的目标 web 站点，并且她使用 Javascript 的小片段来导致浏览器对目标站点中自动进行 HTTP POST。</span><span class="sxs-lookup"><span data-stu-id="1a880-125">The attacker is exploiting the fact that the user might still have a valid authentication token for the target web site, and she is using a small snippet of Javascript to cause the browser to make an HTTP POST to the target site automatically.</span></span> <span data-ttu-id="1a880-126">如果仍有效的身份验证令牌，银行网站将启动到攻击者选择的帐户的 250 美元的传输。</span><span class="sxs-lookup"><span data-stu-id="1a880-126">If the authentication token is still valid, the banking site will initiate a transfer of $250 into the account of the attacker's choosing.</span></span>

### <a name="ineffective-mitigations"></a><span data-ttu-id="1a880-127">无效的缓解措施</span><span class="sxs-lookup"><span data-stu-id="1a880-127">Ineffective mitigations</span></span>

<span data-ttu-id="1a880-128">值得注意的是在上面的方案中，则表明 WoodgroveBank.com 正在通过 SSL 访问，并且必须仅 SSL 身份验证 cookie 已不足以阻止攻击。</span><span class="sxs-lookup"><span data-stu-id="1a880-128">It is interesting to note that in the above scenario, the fact that WoodgroveBank.com was being accessed via SSL and had an SSL-only authentication cookie was insufficient to thwart the attack.</span></span> <span data-ttu-id="1a880-129">攻击者是能够指定[URI 方案](http://en.wikipedia.org/wiki/URI_scheme)(https) 在她&lt;窗体&gt;元素，并浏览器将继续发送到目标站点未过期的 cookie，只要这些 cookie 是一致的 uri预期目标的方案。</span><span class="sxs-lookup"><span data-stu-id="1a880-129">The attacker is able to specify the [URI scheme](http://en.wikipedia.org/wiki/URI_scheme) (https) in her &lt;form&gt; element, and the browser will continue to send unexpired cookies to the target site as long as those cookies are consistent with the URI scheme of the intended target.</span></span>

<span data-ttu-id="1a880-130">有人可能会说，用户应只需不访问不受信任的站点，作为访问仅受信任的站点可帮助联机保持安全。</span><span class="sxs-lookup"><span data-stu-id="1a880-130">One could argue that the user should simply not visit untrusted sites, as visiting only trusted sites is helps to remain safe online.</span></span> <span data-ttu-id="1a880-131">没有为此，某些真实但遗憾的是此建议并不总是可行的。</span><span class="sxs-lookup"><span data-stu-id="1a880-131">There is some truth to this, but unfortunately this advice is not always practical.</span></span> <span data-ttu-id="1a880-132">用户可能是"信任"本地新闻站点 ConsolidatedMessenger。</span><span class="sxs-lookup"><span data-stu-id="1a880-132">Perhaps the user "trusts" the local news site ConsolidatedMessenger.</span></span> <span data-ttu-id="1a880-133">ConsolidatedMessenger.com，直至相反，站点的访问，但该站点具有一个 XSS 漏洞，这样攻击者将注入 fabrikam.com 正在运行的代码的同一代码段。</span><span class="sxs-lookup"><span data-stu-id="1a880-133">ConsolidatedMessenger.com and goes to visit that site instead, but that site has an XSS vulnerability which allows an attacker to inject the same snippet of code that was running on fabrikam.com.</span></span>

<span data-ttu-id="1a880-134">你可以验证传入的请求具有[Referer 标头](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14)引用你的域。</span><span class="sxs-lookup"><span data-stu-id="1a880-134">You can verify that incoming requests have a [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) referencing your domain.</span></span> <span data-ttu-id="1a880-135">这将停止从第三方域无意地提交请求。</span><span class="sxs-lookup"><span data-stu-id="1a880-135">This will stop requests unwittingly submitted from a third-party domain.</span></span> <span data-ttu-id="1a880-136">但是，一些人禁用出于隐私原因，其浏览器的引用站点标头和牺牲品未安装某些不安全软件时，攻击者可以有时伪装成该标头。</span><span class="sxs-lookup"><span data-stu-id="1a880-136">However, some people disable their browser's Referer header for privacy reasons, and attackers can sometimes spoof that header if the victim has certain insecure software installed.</span></span> <span data-ttu-id="1a880-137">验证[Referer 标头](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14)不被视为阻止 XSRF 攻击的安全方法。</span><span class="sxs-lookup"><span data-stu-id="1a880-137">Verifying the [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) is not considered a secure approach to preventing XSRF attacks.</span></span>

## <a name="web-stack-runtime-xsrf-mitigations"></a><span data-ttu-id="1a880-138">Web 堆栈运行时 XSRF 缓解措施</span><span class="sxs-lookup"><span data-stu-id="1a880-138">Web Stack Runtime XSRF mitigations</span></span>

<span data-ttu-id="1a880-139">ASP.NET Web 堆栈运行时使用的一个变体[同步器令牌模式](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern)防御 XSRF 攻击。</span><span class="sxs-lookup"><span data-stu-id="1a880-139">The ASP.NET Web Stack Runtime uses a variant of the [synchronizer token pattern](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern) to defend against XSRF attacks.</span></span> <span data-ttu-id="1a880-140">同步器令牌模式的一般形式是两个 ANTI-XSRF 令牌使用 （除了身份验证令牌） 的每个 HTTP POST 向服务器提交： 作为 cookie，窗体值作为另一个令牌。</span><span class="sxs-lookup"><span data-stu-id="1a880-140">The general form of the synchronizer token pattern is that two anti-XSRF tokens are submitted to the server with each HTTP POST (In addition to the authentication token): one token as a cookie, and the other as a form value.</span></span> <span data-ttu-id="1a880-141">ASP.NET 运行时生成的令牌值不是确定性或攻击者可预测。</span><span class="sxs-lookup"><span data-stu-id="1a880-141">The token values generated by the ASP.NET runtime are not deterministic or predictable by an attacker.</span></span> <span data-ttu-id="1a880-142">提交令牌，服务器将允许的请求仅在两种令牌通过比较检查时，才继续。</span><span class="sxs-lookup"><span data-stu-id="1a880-142">When the tokens are submitted, the server will allow the request to proceed only if both tokens pass a comparison check.</span></span>

<span data-ttu-id="1a880-143">XSRF 请求验证*会话令牌*HTTP cookie 作为存储和当前包含其有效负载中的以下信息：</span><span class="sxs-lookup"><span data-stu-id="1a880-143">The XSRF request verification *session token* is stored as an HTTP cookie and currently contains the following information in its payload:</span></span>

- <span data-ttu-id="1a880-144">安全令牌中，包含随机的 128 位标识符。</span><span class="sxs-lookup"><span data-stu-id="1a880-144">A security token, consisting of a random 128-bit identifier.</span></span>   
 <span data-ttu-id="1a880-145">下图显示了与 Internet Explorer F12 开发人员工具显示 XSRF 请求验证会话令牌: (请注意这是当前的实现，并且主题，甚至可能会，更改。)</span><span class="sxs-lookup"><span data-stu-id="1a880-145">The following image shows the XSRF request verification session token displayed with the Internet Explorer F12 developer tools: (Note this is the current implementation and is subject, even likely, to change.)</span></span>

![](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/_static/image1.png)

<span data-ttu-id="1a880-146">*字段标记*存储为`<input type="hidden" />`并包含其有效负载中的以下信息：</span><span class="sxs-lookup"><span data-stu-id="1a880-146">The *field token* is stored as an `<input type="hidden" />` and contains the following information in its payload:</span></span>

- <span data-ttu-id="1a880-147">登录的用户的用户名 （如果通过身份验证）。</span><span class="sxs-lookup"><span data-stu-id="1a880-147">The logged-in user's username (if authenticated).</span></span>
- <span data-ttu-id="1a880-148">提供的任何其他数据[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)。</span><span class="sxs-lookup"><span data-stu-id="1a880-148">Any additional data provided by an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).</span></span>

<span data-ttu-id="1a880-149">ANTI-XSRF 令牌的负载进行加密和签名，以便使用工具来检查令牌时，不能查看的用户名。</span><span class="sxs-lookup"><span data-stu-id="1a880-149">The payloads of the anti-XSRF tokens are encrypted and signed, so you can't view the username when using tools to examine the tokens.</span></span> <span data-ttu-id="1a880-150">如果 web 应用程序目标 ASP.NET 4.0，加密服务提供的[MachineKey.Encode](https://msdn.microsoft.com/en-us/library/system.web.security.machinekey.encode.aspx)例程。</span><span class="sxs-lookup"><span data-stu-id="1a880-150">When the web application is targeting ASP.NET 4.0, cryptographic services are provided by the [MachineKey.Encode](https://msdn.microsoft.com/en-us/library/system.web.security.machinekey.encode.aspx) routine.</span></span> <span data-ttu-id="1a880-151">当 web 应用程序针对 ASP.NET 4.5 或更高版本的加密服务提供的[MachineKey.Protect](https://msdn.microsoft.com/en-us/library/system.web.security.machinekey.protect(v=vs.110))例程，可提供更好的性能、 可扩展性和安全性。</span><span class="sxs-lookup"><span data-stu-id="1a880-151">When the web application is targeting ASP.NET 4.5 or higher, cryptographic services are provided by the [MachineKey.Protect](https://msdn.microsoft.com/en-us/library/system.web.security.machinekey.protect(v=vs.110)) routine, which offers better performance, extensibility, and security.</span></span> <span data-ttu-id="1a880-152">请参阅以下博客文章的更多详细信息：</span><span class="sxs-lookup"><span data-stu-id="1a880-152">See the following blog posts for more details:</span></span>

- [<span data-ttu-id="1a880-153">在 ASP.NET 4.5 中的加密改进、 pt。1</span><span class="sxs-lookup"><span data-stu-id="1a880-153">Cryptographic Improvements in ASP.NET 4.5, pt. 1</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/22/cryptographic-improvements-in-asp-net-4-5-pt-1.aspx)
- [<span data-ttu-id="1a880-154">在 ASP.NET 4.5 中的加密改进、 pt。2</span><span class="sxs-lookup"><span data-stu-id="1a880-154">Cryptographic Improvements in ASP.NET 4.5, pt. 2</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/23/cryptographic-improvements-in-asp-net-4-5-pt-2.aspx)
- [<span data-ttu-id="1a880-155">在 ASP.NET 4.5 中的加密改进、 pt。3</span><span class="sxs-lookup"><span data-stu-id="1a880-155">Cryptographic Improvements in ASP.NET 4.5, pt. 3</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/24/cryptographic-improvements-in-asp-net-4-5-pt-3.aspx)

## <a name="generating-the-tokens"></a><span data-ttu-id="1a880-156">生成令牌</span><span class="sxs-lookup"><span data-stu-id="1a880-156">Generating the tokens</span></span>

<span data-ttu-id="1a880-157">若要生成的 ANTI-XSRF 令牌，请调用[ @Html.AntiForgeryToken ](https://msdn.microsoft.com/en-us/library/dd470175.aspx)从的 MVC 视图的方法或@AntiForgery.GetHtml从 Razor 页 （)。</span><span class="sxs-lookup"><span data-stu-id="1a880-157">To generate the anti-XSRF tokens, call the [@Html.AntiForgeryToken](https://msdn.microsoft.com/en-us/library/dd470175.aspx) method from an MVC view or @AntiForgery.GetHtml() from a Razor page.</span></span> <span data-ttu-id="1a880-158">然后，运行时将执行以下步骤：</span><span class="sxs-lookup"><span data-stu-id="1a880-158">The runtime will then perform the following steps:</span></span>

1. <span data-ttu-id="1a880-159">如果当前 HTTP 请求已包含的 ANTI-XSRF 会话令牌 (ANTI-XSRF cookie \_ \_RequestVerificationToken)，从其提取的安全令牌。</span><span class="sxs-lookup"><span data-stu-id="1a880-159">If the current HTTP request already contains an anti-XSRF session token (the anti-XSRF cookie \_\_RequestVerificationToken), the security token is extracted from it.</span></span> <span data-ttu-id="1a880-160">如果 HTTP 请求不包含 ANTI-XSRF 会话令牌或安全令牌提取失败，将生成新的随机的 ANTI-XSRF 令牌。</span><span class="sxs-lookup"><span data-stu-id="1a880-160">If the HTTP request does not contain an anti-XSRF session token or if extraction of the security token fails, a new random anti-XSRF token will be generated.</span></span>
2. <span data-ttu-id="1a880-161">ANTI-XSRF 字段标记为生成使用从上面的步骤 (1) 和标识的当前登录的用户的安全令牌。</span><span class="sxs-lookup"><span data-stu-id="1a880-161">An anti-XSRF field token is generated using the security token from step (1) above and the identity of the current logged-in user.</span></span> <span data-ttu-id="1a880-162">(有关确定用户标识的详细信息，请参阅**[具有特殊的支持方案](#_Scenarios_with_special)**下面一节。)此外，如果[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/en-us/library/jj158328(v=vs.111).aspx)是配置，运行时将调用其[GetAdditionalData](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx)方法并将返回的字符串包括在字段标记。</span><span class="sxs-lookup"><span data-stu-id="1a880-162">(For more information on determining user identity, see the **[Scenarios with special support](#_Scenarios_with_special)** section below.) Additionally, if an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/en-us/library/jj158328(v=vs.111).aspx) is configured, the runtime will call its [GetAdditionalData](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) method and include the returned string in the field token.</span></span> <span data-ttu-id="1a880-163">(请参阅**[配置和可扩展性](#_Configuration_and_extensibility)**部分以了解更多信息。)</span><span class="sxs-lookup"><span data-stu-id="1a880-163">(See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.)</span></span>
3. <span data-ttu-id="1a880-164">如果在步骤 (1) 中生成新的 ANTI-XSRF 令牌，新的会话令牌将创建包含它，并且将添加到出站 HTTP cookie 集合。</span><span class="sxs-lookup"><span data-stu-id="1a880-164">If a new anti-XSRF token was generated in step (1), a new session token will be created to contain it and will be added to the outbound HTTP cookies collection.</span></span> <span data-ttu-id="1a880-165">步骤 (2) 中的字段令牌将包装在`<input type="hidden" />`元素，并且此 HTML 标记将是的返回值`Html.AntiForgeryToken()`或`AntiForgery.GetHtml()`。</span><span class="sxs-lookup"><span data-stu-id="1a880-165">The field token from step (2) will be wrapped in an `<input type="hidden" />` element, and this HTML markup will be the return value of `Html.AntiForgeryToken()` or `AntiForgery.GetHtml()`.</span></span>

## <a name="validating-the-tokens"></a><span data-ttu-id="1a880-166">验证令牌</span><span class="sxs-lookup"><span data-stu-id="1a880-166">Validating the tokens</span></span>

<span data-ttu-id="1a880-167">若要验证传入的 ANTI-XSRF 令牌，开发人员包括[ValidateAntiForgeryToken](https://msdn.microsoft.com/en-us/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx)她 MVC 操作或控制器或她调用特性`@AntiForgery.Validate()`从她 Razor 页。</span><span class="sxs-lookup"><span data-stu-id="1a880-167">To validate the incoming anti-XSRF tokens, the developer includes a [ValidateAntiForgeryToken](https://msdn.microsoft.com/en-us/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) attribute on her MVC action or controller, or she calls `@AntiForgery.Validate()` from her Razor page.</span></span> <span data-ttu-id="1a880-168">运行时将执行以下步骤：</span><span class="sxs-lookup"><span data-stu-id="1a880-168">The runtime will perform the following steps:</span></span>

1. <span data-ttu-id="1a880-169">读取的传入会话令牌和字段标记，并从每个提取 ANTI-XSRF 令牌。</span><span class="sxs-lookup"><span data-stu-id="1a880-169">The incoming session token and field token are read and the anti-XSRF token extracted from each.</span></span> <span data-ttu-id="1a880-170">ANTI-XSRF 令牌必须每个步骤 (2) 生成例程中相同。</span><span class="sxs-lookup"><span data-stu-id="1a880-170">The anti-XSRF tokens must be identical per step (2) in the generation routine.</span></span>
2. <span data-ttu-id="1a880-171">如果当前用户进行身份验证，与字段标记中存储的用户名进行比较她的用户名。</span><span class="sxs-lookup"><span data-stu-id="1a880-171">If the current user is authenticated, her username is compared with the username stored in the field token.</span></span> <span data-ttu-id="1a880-172">用户名必须与匹配。</span><span class="sxs-lookup"><span data-stu-id="1a880-172">The usernames must match.</span></span>
3. <span data-ttu-id="1a880-173">如果[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)配置，则运行时会调用其*ValidateAdditionalData*方法。</span><span class="sxs-lookup"><span data-stu-id="1a880-173">If an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) is configured, the runtime calls its *ValidateAdditionalData* method.</span></span> <span data-ttu-id="1a880-174">该方法必须返回布尔值*true*。</span><span class="sxs-lookup"><span data-stu-id="1a880-174">The method must return the Boolean value *true*.</span></span>

<span data-ttu-id="1a880-175">如果验证成功，则允许请求以继续。</span><span class="sxs-lookup"><span data-stu-id="1a880-175">If validation succeeds, the request is allowed to proceed.</span></span> <span data-ttu-id="1a880-176">如果验证失败，将引发 framework *HttpAntiForgeryException*。</span><span class="sxs-lookup"><span data-stu-id="1a880-176">If validation fails, the framework will throw an *HttpAntiForgeryException*.</span></span>

## <a name="failure-conditions"></a><span data-ttu-id="1a880-177">失败条件</span><span class="sxs-lookup"><span data-stu-id="1a880-177">Failure conditions</span></span>

<span data-ttu-id="1a880-178">任何从 ASP.NET Web 堆栈运行 v2 *HttpAntiForgeryException*期间引发验证将包含有关发生的问题的详细的信息。</span><span class="sxs-lookup"><span data-stu-id="1a880-178">Starting with The ASP.NET Web Stack Runtime v2, any *HttpAntiForgeryException* that is thrown during validation will contain detailed information about what went wrong.</span></span> <span data-ttu-id="1a880-179">当前定义的失败条件是：</span><span class="sxs-lookup"><span data-stu-id="1a880-179">The currently defined failure conditions are:</span></span>

- <span data-ttu-id="1a880-180">不存在请求中的会话令牌或窗体标记。</span><span class="sxs-lookup"><span data-stu-id="1a880-180">The session token or form token is not present in the request.</span></span>
- <span data-ttu-id="1a880-181">会话令牌或窗体令牌不可读。</span><span class="sxs-lookup"><span data-stu-id="1a880-181">The session token or form token is unreadable.</span></span> <span data-ttu-id="1a880-182">此最可能的原因是在运行的 ASP.NET Web 堆栈运行时或场的版本不匹配的场其中&lt;machineKey&gt;机之间不同，在 Web.config 中的元素。</span><span class="sxs-lookup"><span data-stu-id="1a880-182">The most likely cause of this is a farm running mismatched versions of The ASP.NET Web Stack Runtime or a farm where the &lt;machineKey&gt; element in Web.config differs between machines.</span></span> <span data-ttu-id="1a880-183">Fiddler 等工具可用于通过篡改任一 ANTI-XSRF 令牌强制此异常。</span><span class="sxs-lookup"><span data-stu-id="1a880-183">You can use a tool such as Fiddler to force this exception by tampering with either anti-XSRF token.</span></span>
- <span data-ttu-id="1a880-184">会话令牌和字段令牌已交换。</span><span class="sxs-lookup"><span data-stu-id="1a880-184">The session token and field token were swapped.</span></span>
- <span data-ttu-id="1a880-185">会话令牌和字段标记包含不匹配的安全令牌。</span><span class="sxs-lookup"><span data-stu-id="1a880-185">The session token and field token contain mismatched security tokens.</span></span>
- <span data-ttu-id="1a880-186">字段标记中嵌入用户名与当前登录的用户的用户名不匹配。</span><span class="sxs-lookup"><span data-stu-id="1a880-186">The username embedded within the field token does not match the current logged-in user's username.</span></span>
- <span data-ttu-id="1a880-187"> *[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* 方法返回*false*。</span><span class="sxs-lookup"><span data-stu-id="1a880-187">The *[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* method returned *false*.</span></span>

<span data-ttu-id="1a880-188">ANTI-XSRF 设施可能还执行生成令牌或验证过程的其他检查，这些检查期间出现的故障可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="1a880-188">The anti-XSRF facilities may also perform additional checking during token generation or validation, and failures during these checks may result in exceptions being thrown.</span></span> <span data-ttu-id="1a880-189">请参阅[WIF / ACS / 基于声明的身份验证](#_WIF_ACS)和**[配置和可扩展性](#_Configuration_and_extensibility)**部分以获取更多信息。</span><span class="sxs-lookup"><span data-stu-id="1a880-189">See the [WIF / ACS / claims-based authentication](#_WIF_ACS) and **[Configuration and extensibility](#_Configuration_and_extensibility)** sections for more information.</span></span>

<a id="_Scenarios_with_special"></a>

## <a name="scenarios-with-special-support"></a><span data-ttu-id="1a880-190">使用特殊的支持方案</span><span class="sxs-lookup"><span data-stu-id="1a880-190">Scenarios with special support</span></span>

### <a name="anonymous-authentication"></a><span data-ttu-id="1a880-191">匿名身份验证</span><span class="sxs-lookup"><span data-stu-id="1a880-191">Anonymous authentication</span></span>

<span data-ttu-id="1a880-192">ANTI-XSRF 系统包含额外支持匿名用户，其中"匿名"指用户其中*IIdentity.IsAuthenticated*属性返回*false*。</span><span class="sxs-lookup"><span data-stu-id="1a880-192">The anti-XSRF system contains special support for anonymous users, where "anonymous" is defined as a user where the *IIdentity.IsAuthenticated* property returns *false*.</span></span> <span data-ttu-id="1a880-193">方案包括提供 XSRF 保护的登录页 （之前用户进行身份验证） 和自定义身份验证方案，其中应用程序使用一种机制不*IIdentity*来识别用户。</span><span class="sxs-lookup"><span data-stu-id="1a880-193">Scenarios include providing XSRF protection to the login page (before the user is authenticated) and custom authentication schemes where the application uses a mechanism other than *IIdentity* to identify users.</span></span>

<span data-ttu-id="1a880-194">若要支持这些方案，请记住的会话和字段令牌通过安全令牌，这是一个 128 位随机生成不透明标识符联接。</span><span class="sxs-lookup"><span data-stu-id="1a880-194">To support these scenarios, recall that the session and field tokens are joined by a security token, which is a 128-bit randomly-generated opaque identifier.</span></span> <span data-ttu-id="1a880-195">此安全令牌用于跟踪单个用户会话，当她导航站点，以便有效地提供服务的匿名标识符的用途。</span><span class="sxs-lookup"><span data-stu-id="1a880-195">This security token is used to track an individual user's session as she navigates the site, so it effectively serves the purpose of an anonymous identifier.</span></span> <span data-ttu-id="1a880-196">空字符串用于代替用户名上面所述的生成和验证例程。</span><span class="sxs-lookup"><span data-stu-id="1a880-196">An empty string is used in place of the username for the generation and validation routines described above.</span></span>

<a id="_WIF_ACS"></a>

### <a name="wif--acs--claims-based-authentication"></a><span data-ttu-id="1a880-197">WIF / ACS / 基于声明的身份验证</span><span class="sxs-lookup"><span data-stu-id="1a880-197">WIF / ACS / claims-based authentication</span></span>

<span data-ttu-id="1a880-198">通常情况下， *IIdentity*内置于.NET Framework 的类具有属性， *IIdentity.Name*足以唯一地标识特定的应用程序内的特定用户。</span><span class="sxs-lookup"><span data-stu-id="1a880-198">Normally, the *IIdentity* classes built in to the .NET Framework have the property that *IIdentity.Name* is sufficient to uniquely identify a particular user within a particular application.</span></span> <span data-ttu-id="1a880-199">例如， *FormsIdentity.Name*返回存储在成员资格数据库 （这是唯一的具体取决于该数据库的所有应用程序），用户名*WindowsIdentity.Name*返回域限定标识用户，依次类推。</span><span class="sxs-lookup"><span data-stu-id="1a880-199">For example, *FormsIdentity.Name* returns the username stored in the membership database (which is unique for all applications depending on that database), *WindowsIdentity.Name* returns the domain-qualified identity of the user, and so on.</span></span> <span data-ttu-id="1a880-200">这些系统提供不仅身份验证;它们还*标识*到应用程序的用户。</span><span class="sxs-lookup"><span data-stu-id="1a880-200">These systems provide not only authentication; they also *identify* users to an application.</span></span>

<span data-ttu-id="1a880-201">基于声明的身份验证，另一方面，不一定需要标识特定用户。</span><span class="sxs-lookup"><span data-stu-id="1a880-201">Claims-based authentication, on the other hand, does not necessarily require identifying a particular user.</span></span> <span data-ttu-id="1a880-202">相反， *ClaimsPrincipal*和*ClaimsIdentity*类型都与一组相关联*声明*实例，其中的单个声明可能是"is 岁 18 +"或"是的管理员"为任何其他值。</span><span class="sxs-lookup"><span data-stu-id="1a880-202">Instead, the *ClaimsPrincipal* and *ClaimsIdentity* types are associated with a set of *Claim* instances, where the individual claims might be "is 18+ years of age" or "is an administrator" to anything else.</span></span> <span data-ttu-id="1a880-203">由于尚未一定标识该用户，不能使用运行时*ClaimsIdentity.Name*属性作为该特定用户的唯一标识符。</span><span class="sxs-lookup"><span data-stu-id="1a880-203">Since the user hasn't necessarily been identified, the runtime cannot use the *ClaimsIdentity.Name* property as a unique identifier for this particular user.</span></span> <span data-ttu-id="1a880-204">团队已发现实际应用示例其中*ClaimsIdentity.Name*返回*null*、 返回友好 （显示） 名称，或否则将返回一个字符串，并不适合用作唯一标识符为用户。</span><span class="sxs-lookup"><span data-stu-id="1a880-204">The team has seen real-world examples where *ClaimsIdentity.Name* returns *null*, returns a friendly (display) name, or otherwise returns a string that isn't appropriate for use as a unique identifier for the user.</span></span>

<span data-ttu-id="1a880-205">许多使用基于声明的身份验证的部署使用[Azure Access Control 服务](https://msdn.microsoft.com/en-us/library/windowsazure/gg429786.aspx)(ACS) 尤其。</span><span class="sxs-lookup"><span data-stu-id="1a880-205">Many of deployments which use claims-based authentication are using [Azure Access Control Service](https://msdn.microsoft.com/en-us/library/windowsazure/gg429786.aspx) (ACS) in particular.</span></span> <span data-ttu-id="1a880-206">ACS 允许开发人员配置单个*标识提供程序*（ADFS，Microsoft 帐户提供程序，如 OpenID 提供程序如 yahoo ！ 等），并标识提供程序返回*命名标识符*.</span><span class="sxs-lookup"><span data-stu-id="1a880-206">ACS allows the developer to configure individual *identity providers* (such as ADFS, the Microsoft Account provider, OpenID providers like Yahoo!, etc.), and the identity providers return *name identifiers*.</span></span> <span data-ttu-id="1a880-207">这些名称标识符可能包含个人身份信息 (PII)，如电子邮件地址，或它们无法将匿名处理如专用个人标识符 (PPID)。</span><span class="sxs-lookup"><span data-stu-id="1a880-207">These name identifiers may contain Personally Identifiable Information (PII) like an email address, or they could be anonymized like a Private Personal Identifier (PPID).</span></span> <span data-ttu-id="1a880-208">无论如何，元组 （名称标识符中的标识提供程序） 足够作为特定用户的适当的跟踪令牌，而她浏览站点，以便在生成时，ASP.NET Web 堆栈运行时可以使用此元组代替用户名和验证 ANTI-XSRF 字段令牌。</span><span class="sxs-lookup"><span data-stu-id="1a880-208">Regardless, the tuple (identity provider, name identifier) sufficiently serves as an appropriate tracking token for a particular user while she is browsing the site, so the ASP.NET Web Stack Runtime can use the tuple in place of the username when generating and validating anti-XSRF field tokens.</span></span> <span data-ttu-id="1a880-209">标识提供程序和名称标识符的特定 Uri 是：</span><span class="sxs-lookup"><span data-stu-id="1a880-209">The particular URIs for the identity provider and the name identifier are :</span></span>

- `http://schemas.microsoft.com/accesscontrolservice/2010/07/claims/identityprovider`
- `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier`

<span data-ttu-id="1a880-210">(请参阅此[ACS 文档页](https://msdn.microsoft.com/en-us/library/windowsazure/gg185971.aspx)有关详细信息。)</span><span class="sxs-lookup"><span data-stu-id="1a880-210">(see this [ACS doc page](https://msdn.microsoft.com/en-us/library/windowsazure/gg185971.aspx) for more info.)</span></span>

<span data-ttu-id="1a880-211">当生成或验证令牌时，ASP.NET Web 堆栈运行时将在运行时尝试绑定到类型：</span><span class="sxs-lookup"><span data-stu-id="1a880-211">When generating or validating a token, the ASP.NET Web Stack Runtime will at runtime try binding to the types:</span></span>

- <span data-ttu-id="1a880-212">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35`（有关 WIF SDK。)</span><span class="sxs-lookup"><span data-stu-id="1a880-212">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (For the WIF SDK.)</span></span>
- <span data-ttu-id="1a880-213">`System.Security.Claims.ClaimsIdentity`（用于.NET 4.5)。</span><span class="sxs-lookup"><span data-stu-id="1a880-213">`System.Security.Claims.ClaimsIdentity` (For .NET 4.5).</span></span>

<span data-ttu-id="1a880-214">如果这些类型存在，并且当前用户的*IIIIdentity*实现或子类其中一种类型，（标识提供程序，名称标识符），将使用的 ANTI-XSRF 设施代替用户名生成时的元组和验证令牌。</span><span class="sxs-lookup"><span data-stu-id="1a880-214">If these types exist, and if the current user's *IIIIdentity* implements or subclasses one of these types, the anti-XSRF facility will use the (identity provider, name identifier) tuple in place of the username when generating and validating the tokens.</span></span> <span data-ttu-id="1a880-215">如果存在任何此类元组，不则请求将失败并出错到开发人员描述如何配置 ANTI-XSRF 系统，以便了解中使用的特定基于声明的身份验证机制。</span><span class="sxs-lookup"><span data-stu-id="1a880-215">If no such tuple is present, the request will fail with an error describing to the developer how to configure the anti-XSRF system to understand the particular claims-based authentication mechanism in use.</span></span> <span data-ttu-id="1a880-216">请参阅**[配置和可扩展性](#_Configuration_and_extensibility)**部分以了解更多信息。</span><span class="sxs-lookup"><span data-stu-id="1a880-216">See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.</span></span>

### <a name="oauth--openid-authentication"></a><span data-ttu-id="1a880-217">OAuth / OpenID 身份验证</span><span class="sxs-lookup"><span data-stu-id="1a880-217">OAuth / OpenID authentication</span></span>

<span data-ttu-id="1a880-218">最后，ANTI-XSRF 设施具有应用程序的使用 OAuth 或 OpenID 身份验证的特殊的支持。</span><span class="sxs-lookup"><span data-stu-id="1a880-218">Finally, the anti-XSRF facility has special support for applications which use OAuth or OpenID authentication.</span></span> <span data-ttu-id="1a880-219">此支持是基于启发式方法的： 如果当前*IIdentity.Name*开始 http:// 或 https:// 开头，则将完成用户名比较使用序号比较器，而不是默认 OrdinalIgnoreCase 比较器。</span><span class="sxs-lookup"><span data-stu-id="1a880-219">This support is heuristic-based: if the current *IIdentity.Name* begins with http:// or https://, then username comparisons will be done using an Ordinal comparer rather than the default OrdinalIgnoreCase comparer.</span></span>

<a id="_Configuration_and_extensibility"></a>

## <a name="configuration-and-extensibility"></a><span data-ttu-id="1a880-220">配置和可扩展性</span><span class="sxs-lookup"><span data-stu-id="1a880-220">Configuration and extensibility</span></span>

<span data-ttu-id="1a880-221">有时，开发人员可能想更加严格地控制 ANTI-XSRF 生成和验证行为。</span><span class="sxs-lookup"><span data-stu-id="1a880-221">Occasionally, developers may want tighter control over the anti-XSRF generation and validation behaviors.</span></span> <span data-ttu-id="1a880-222">例如，可能会自动将 HTTP cookie 添加到响应的 MVC 和 Web Pages 帮助器的默认行为是不可取，和开发人员可能想要保留在其他位置的令牌。</span><span class="sxs-lookup"><span data-stu-id="1a880-222">For example, perhaps the MVC and Web Pages helpers' default behavior of automatically adding HTTP cookies to the response is undesirable, and the developer may wish to persist the tokens elsewhere.</span></span> <span data-ttu-id="1a880-223">存在两个 Api，以对此有帮助：</span><span class="sxs-lookup"><span data-stu-id="1a880-223">There exist two APIs to assist with this:</span></span>

`AntiForgery.GetTokens(string oldCookieToken, out string newCookieToken, out string formToken);`  
`AntiForgery.Validate(string cookieToken, string formToken);`

<span data-ttu-id="1a880-224">*GetTokens*方法接受的输入现有 XSRF 请求验证会话令牌 （其中可能为 null） 和作为生成输出新 XSRF 请求验证会话令牌和字段令牌。</span><span class="sxs-lookup"><span data-stu-id="1a880-224">The *GetTokens* method takes as input an existing XSRF request verification session token (which may be null) and produces as output a new XSRF request verification session token and field token.</span></span> <span data-ttu-id="1a880-225">令牌是采用不带修饰符; 只是不透明字符串*formToken*值将为实例不能进行包装在&lt;输入&gt;标记。</span><span class="sxs-lookup"><span data-stu-id="1a880-225">The tokens are simply opaque strings with no decoration; the *formToken* value will for instance not be wrapped in an &lt;input&gt; tag.</span></span> <span data-ttu-id="1a880-226">*NewCookieToken*值可能为 null; 如果发生这种情况，则*oldCookieToken*值是仍然有效，并且需要设置任何新的响应 cookie。</span><span class="sxs-lookup"><span data-stu-id="1a880-226">The *newCookieToken* value may be null; if this occurs, then the *oldCookieToken* value is still valid and no new response cookie need be set.</span></span> <span data-ttu-id="1a880-227">调用方*GetTokens*负责保持任何必要的响应 cookie 或生成任何必要的标记; *GetTokens*方法本身不会更改的副作用的响应。</span><span class="sxs-lookup"><span data-stu-id="1a880-227">The caller of *GetTokens* is responsible for persisting any necessary response cookies or generating any necessary markup; the *GetTokens* method itself will not alter the response as a side effect.</span></span> <span data-ttu-id="1a880-228">*验证*方法采用传入会话和字段标记，并且在其运行前面提到的验证逻辑。</span><span class="sxs-lookup"><span data-stu-id="1a880-228">The *Validate* method takes the incoming session and field tokens and runs the aforementioned validation logic over them.</span></span>

### <a name="antiforgeryconfig"></a><span data-ttu-id="1a880-229">AntiForgeryConfig</span><span class="sxs-lookup"><span data-stu-id="1a880-229">AntiForgeryConfig</span></span>

<span data-ttu-id="1a880-230">开发人员可以配置应用程序中的 ANTI-XSRF 系统\_启动。</span><span class="sxs-lookup"><span data-stu-id="1a880-230">The developer may configure the anti-XSRF system from Application\_Start.</span></span> <span data-ttu-id="1a880-231">以编程方式配置。</span><span class="sxs-lookup"><span data-stu-id="1a880-231">Configuration is programmatic.</span></span> <span data-ttu-id="1a880-232">静态属性*AntiForgeryConfig*类型如下所述。</span><span class="sxs-lookup"><span data-stu-id="1a880-232">The properties of the static *AntiForgeryConfig* type are described below.</span></span> <span data-ttu-id="1a880-233">使用声明的大多数用户将想要设置 UniqueClaimTypeIdentifier 属性。</span><span class="sxs-lookup"><span data-stu-id="1a880-233">Most users using claims will want to set the UniqueClaimTypeIdentifier property.</span></span>

| <span data-ttu-id="1a880-234">**Property**</span><span class="sxs-lookup"><span data-stu-id="1a880-234">**Property**</span></span> | <span data-ttu-id="1a880-235">**描述**</span><span class="sxs-lookup"><span data-stu-id="1a880-235">**Description**</span></span> |
| --- | --- |
| <span data-ttu-id="1a880-236">**AdditionalDataProvider**</span><span class="sxs-lookup"><span data-stu-id="1a880-236">**AdditionalDataProvider**</span></span> | <span data-ttu-id="1a880-237">[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) ，令牌生成期间提供的附加数据和令牌验证期间使用额外数据。</span><span class="sxs-lookup"><span data-stu-id="1a880-237">An [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) that provides additional data during token generation and consumes additional data during token validation.</span></span> <span data-ttu-id="1a880-238">默认值是*null*。</span><span class="sxs-lookup"><span data-stu-id="1a880-238">The default value is *null*.</span></span> <span data-ttu-id="1a880-239">有关详细信息，请参阅[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)部分。</span><span class="sxs-lookup"><span data-stu-id="1a880-239">For more information, see the [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) section.</span></span> |
| <span data-ttu-id="1a880-240">**CookieName**</span><span class="sxs-lookup"><span data-stu-id="1a880-240">**CookieName**</span></span> | <span data-ttu-id="1a880-241">提供用于存储的 ANTI-XSRF 会话令牌的 HTTP cookie 的名称的字符串。</span><span class="sxs-lookup"><span data-stu-id="1a880-241">A string that provides the name of the HTTP cookie that is used to store the anti-XSRF session token.</span></span> <span data-ttu-id="1a880-242">如果未设置此值，名称将自动生成基于应用程序的已部署的虚拟路径。</span><span class="sxs-lookup"><span data-stu-id="1a880-242">If this value is not set, a name will be automatically generated based on the application's deployed virtual path.</span></span> <span data-ttu-id="1a880-243">默认值是*null*。</span><span class="sxs-lookup"><span data-stu-id="1a880-243">The default value is *null*.</span></span> |
| <span data-ttu-id="1a880-244">**RequireSsl**</span><span class="sxs-lookup"><span data-stu-id="1a880-244">**RequireSsl**</span></span> | <span data-ttu-id="1a880-245">一个布尔值，指示是否需要通过安全 SSL 通道提交的 ANTI-XSRF 令牌。</span><span class="sxs-lookup"><span data-stu-id="1a880-245">A Boolean that dictates whether the anti-XSRF tokens are required to be submitted over an SSL-secured channel.</span></span> <span data-ttu-id="1a880-246">如果此值为*true*，任何自动生成的 cookie 将具有"安全"标志设置，并且从调用中时不会通过 SSL 提交的请求，则会引发 ANTI-XSRF Api。</span><span class="sxs-lookup"><span data-stu-id="1a880-246">If this value is *true*, any automatically-generated cookies will have the "secure" flag set, and the anti-XSRF APIs will throw if called from within a request that is not submitted via SSL.</span></span> <span data-ttu-id="1a880-247">默认值为“false”。</span><span class="sxs-lookup"><span data-stu-id="1a880-247">The default value is *false*.</span></span> |
| <span data-ttu-id="1a880-248">**SuppressIdentityHeuristicChecks**</span><span class="sxs-lookup"><span data-stu-id="1a880-248">**SuppressIdentityHeuristicChecks**</span></span> | <span data-ttu-id="1a880-249">一个布尔值，指示是否 ANTI-XSRF 系统应停用它对基于声明的标识的支持。</span><span class="sxs-lookup"><span data-stu-id="1a880-249">A Boolean that dictates whether the anti-XSRF system should deactivate its support for claims-based identities.</span></span> <span data-ttu-id="1a880-250">如果此值为*true*，系统将假定*IIdentity.Name*适合作为唯一的每个用户标识符的使用和不会尝试向特殊用例*IClaimsIdentity*或*ClClaimsIdentity*中所述[WIF / ACS / 基于声明的身份验证](#_WIF_ACS)部分。</span><span class="sxs-lookup"><span data-stu-id="1a880-250">If this value is *true*, the system will assume that *IIdentity.Name* is appropriate for use as a unique per-user identifier and will not try to special-case *IClaimsIdentity* or *ClClaimsIdentity* as described in the [WIF / ACS / claims-based authentication](#_WIF_ACS) section.</span></span> <span data-ttu-id="1a880-251">默认值为 `false`。</span><span class="sxs-lookup"><span data-stu-id="1a880-251">The default value is `false`.</span></span> |
| <span data-ttu-id="1a880-252">**UniqueClaimTypeIdentifier**</span><span class="sxs-lookup"><span data-stu-id="1a880-252">**UniqueClaimTypeIdentifier**</span></span> | <span data-ttu-id="1a880-253">一个字符串，指示哪些声明类型是适用于作为唯一的每个用户标识符。</span><span class="sxs-lookup"><span data-stu-id="1a880-253">A string that indicates which claim type is appropriate for use as a unique per-user identifier.</span></span> <span data-ttu-id="1a880-254">如果此值是组和当前*IIdentity*基于声明的则系统将尝试提取一个声明的类型由指定*UniqueClaimTypeIdentifier*，并且将使用相应的值代替生成字段标记时的用户的用户名。</span><span class="sxs-lookup"><span data-stu-id="1a880-254">If this value is set and the current *IIdentity* is claims-based, the system will attempt to extract a claim of the type specified by *UniqueClaimTypeIdentifier*, and the corresponding value will be used in place of the user's username when generating the field token.</span></span> <span data-ttu-id="1a880-255">如果未找到的声明类型，系统将无法发送请求。</span><span class="sxs-lookup"><span data-stu-id="1a880-255">If the claim type is not found, the system will fail the request.</span></span> <span data-ttu-id="1a880-256">默认值是*null*，指示系统应使用 （标识提供程序，名称标识符） 代替用户的用户名如上文所述的元组。</span><span class="sxs-lookup"><span data-stu-id="1a880-256">The default value is *null*, which indicates that the system should use the (identity provider, name identifier) tuple as previously described in place of the user's username.</span></span> |

<a id="_IAntiForgeryAdditionalDataProvider"></a>

### <a name="iantiforgeryadditionaldataprovider"></a><span data-ttu-id="1a880-257">IAntiForgeryAdditionalDataProvider</span><span class="sxs-lookup"><span data-stu-id="1a880-257">IAntiForgeryAdditionalDataProvider</span></span>

<span data-ttu-id="1a880-258"> *[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* 类型允许开发人员通过往返中每个令牌的其他数据扩展的 ANTI-XSRF 系统的行为。</span><span class="sxs-lookup"><span data-stu-id="1a880-258">The *[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/en-us/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* type allows developers to extend the behavior of the anti-XSRF system by round-tripping additional data in each token.</span></span> <span data-ttu-id="1a880-259">*GetAdditionalData*每次调用方法生成的字段标记，和在生成的标记内嵌入的返回值。</span><span class="sxs-lookup"><span data-stu-id="1a880-259">The *GetAdditionalData* method is called each time a field token is generated, and the return value is embedded within the generated token.</span></span> <span data-ttu-id="1a880-260">实施者无法通过此方法返回时间戳、 一个 nonce 或她希望的任何其他值。</span><span class="sxs-lookup"><span data-stu-id="1a880-260">An implementer could return a timestamp, a nonce, or any other value she wishes from this method.</span></span>

<span data-ttu-id="1a880-261">同样， *ValidateAdditionalData*每次调用方法将验证字段标记，并且已在令牌内嵌入的"其他数据"字符串传递给方法。</span><span class="sxs-lookup"><span data-stu-id="1a880-261">Similarly, the *ValidateAdditionalData* method is called each time a field token is validated, and the "additional data" string that was embedded within the token is passed to the method.</span></span> <span data-ttu-id="1a880-262">验证例程无法实现超时 （通过检查当前时间，但创建令牌时存储的时间）、 nonce 检查例程，或任何其他所需的逻辑。</span><span class="sxs-lookup"><span data-stu-id="1a880-262">The validation routine could implement a timeout (by checking the current time against the time that was stored when the token was created), a nonce checking routine, or any other desired logic.</span></span>

## <a name="design-decisions-and-security-considerations"></a><span data-ttu-id="1a880-263">设计决策和安全注意事项</span><span class="sxs-lookup"><span data-stu-id="1a880-263">Design decisions and security considerations</span></span>

<span data-ttu-id="1a880-264">链接的会话和字段令牌的安全令牌从技术上讲时才需要尝试保护免受 XSRF 攻击匿名 / 未经身份验证的用户。</span><span class="sxs-lookup"><span data-stu-id="1a880-264">The security token that links the session and field tokens is technically only necessary when trying to protect anonymous / unauthenticated users against XSRF attacks.</span></span> <span data-ttu-id="1a880-265">当用户进行身份验证时，可使用的身份验证令牌本身 （大概 cookie 形式提交） 作为一个一半同步器令牌对。</span><span class="sxs-lookup"><span data-stu-id="1a880-265">When the user is authenticated, the authentication token itself (presumably submitted in the form of a cookie) could be used as one half of a synchronizer token pair.</span></span> <span data-ttu-id="1a880-266">但是，有保护命中由未经身份验证的用户的登录页的有效方案和 ANTI-XSRF 逻辑进行更简单始终生成和验证安全令牌，即使对于经过身份验证的用户。</span><span class="sxs-lookup"><span data-stu-id="1a880-266">However, there are valid scenarios for protecting login pages hit by unauthenticated users, and the anti-XSRF logic was made simpler by always generating and validating the security token, even for authenticated users.</span></span> <span data-ttu-id="1a880-267">中，字段标记曾经受到攻击，作为设置或猜测会话令牌攻击者能够克服的另一个障碍，它还未提供一些额外的保护。</span><span class="sxs-lookup"><span data-stu-id="1a880-267">It also does provide some additional protection in the event that a field token is ever compromised by an attacker, as setting or guessing the session token would be another hurdle for the attacker to overcome.</span></span>

<span data-ttu-id="1a880-268">当多个应用程序承载在单个域中时，开发人员应小心。</span><span class="sxs-lookup"><span data-stu-id="1a880-268">Developers should use caution when multiple applications are hosted in a single domain.</span></span> <span data-ttu-id="1a880-269">例如，即使*example1.cloudapp.net*和*example2.cloudapp.net*是不同的主机下的所有主机之间没有隐式信任关系 *\*。 cloudapp.net*域。</span><span class="sxs-lookup"><span data-stu-id="1a880-269">For example, even though *example1.cloudapp.net* and *example2.cloudapp.net* are different hosts, there is an implicit trust relationship between all hosts under the *\*.cloudapp.net* domain.</span></span> <span data-ttu-id="1a880-270">此隐式信任关系[让影响对方的 cookie 可能不受信任的主机](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks)（控制 AJAX 请求的同源策略不一定适用于 HTTP cookie）。</span><span class="sxs-lookup"><span data-stu-id="1a880-270">This implicit trust relationship [allows potentially untrusted hosts to affect each other's cookies](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (the same-origin policies that govern AJAX requests do not necessarily apply to HTTP cookies).</span></span> <span data-ttu-id="1a880-271">ASP.NET Web 堆栈运行时，用户名将嵌入到字段令牌中，因此即使恶意的子域是能够覆盖会话令牌将无法生成有效字段标记以该用户提供一些缓解。</span><span class="sxs-lookup"><span data-stu-id="1a880-271">The ASP.NET Web Stack Runtime provides some mitigation in that the username is embedded into the field token, so even if a malicious subdomain is able to overwrite a session token it will be unable to generate a valid field token for the user.</span></span> <span data-ttu-id="1a880-272">但是，在这种环境中承载时的内置的 ANTI-XSRF 例程仍不能抵御会话劫持或登录名 XSRF。</span><span class="sxs-lookup"><span data-stu-id="1a880-272">However, when hosted in such an environment the built-in anti-XSRF routines still cannot defend against session hijacking or login XSRF.</span></span>

<span data-ttu-id="1a880-273">ANTI-XSRF 例程当前是否不抵御[clickjacking](https://www.owasp.org/index.php/Clickjacking)。</span><span class="sxs-lookup"><span data-stu-id="1a880-273">The anti-XSRF routines currently do not defend against [clickjacking](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="1a880-274">想要针对 clickjacking 保护他们自己的应用程序可以轻松完成此操作发送 X 框架选项： SAMEORIGIN 与每个响应的标头。</span><span class="sxs-lookup"><span data-stu-id="1a880-274">Applications that wish to defend themselves against clickjacking may easily do so by sending an X-Frame-Options: SAMEORIGIN header with each response.</span></span> <span data-ttu-id="1a880-275">所有新的浏览器都支持此标头。</span><span class="sxs-lookup"><span data-stu-id="1a880-275">This header is supported by all recent browsers.</span></span> <span data-ttu-id="1a880-276">有关详细信息，请参阅[IE 博客](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx)、 [SDL 博客](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx)，和[OWASP](https://www.owasp.org/index.php/Clickjacking)。</span><span class="sxs-lookup"><span data-stu-id="1a880-276">For more information, see the [IE blog](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), the [SDL blog](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx), and [OWASP](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="1a880-277">ASP.NET Web 堆栈运行时可在一些将来的版本进行 MVC 和 Web 页的 ANTI-XSRF 帮助器自动设置此标头，以便应用程序已自动受到保护针对这种攻击。</span><span class="sxs-lookup"><span data-stu-id="1a880-277">The ASP.NET Web Stack Runtime may in some future release make the MVC and Web Pages anti-XSRF helpers automatically set this header so that applications are automatically protected against this attack.</span></span>

<span data-ttu-id="1a880-278">Web 开发人员应继续以确保它们的站点不是很容易受到 XSS 攻击。</span><span class="sxs-lookup"><span data-stu-id="1a880-278">Web developers should continue to ensure that their site is not vulnerable to XSS attacks.</span></span> <span data-ttu-id="1a880-279">XSS 攻击是非常强大，并成功利用此漏洞也将会破坏 ASP.NET Web 堆栈运行时防御 XSRF 攻击。</span><span class="sxs-lookup"><span data-stu-id="1a880-279">XSS attacks are very powerful, and a successful exploit would also break the ASP.NET Web Stack Runtime defenses against XSRF attacks.</span></span>

## <a name="acknowledgment"></a><span data-ttu-id="1a880-280">确认</span><span class="sxs-lookup"><span data-stu-id="1a880-280">Acknowledgment</span></span>

<span data-ttu-id="1a880-281">[@LeviBroderick](https://twitter.com/LeviBroderick)谁写入 ASP.NET 安全代码大部分此信息的大容量。</span><span class="sxs-lookup"><span data-stu-id="1a880-281">[@LeviBroderick](https://twitter.com/LeviBroderick), who wrote much of the ASP.NET security code the bulk of this information.</span></span>
