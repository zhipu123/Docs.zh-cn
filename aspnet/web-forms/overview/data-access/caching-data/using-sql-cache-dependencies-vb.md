---
uid: web-forms/overview/data-access/caching-data/using-sql-cache-dependencies-vb
title: "使用 SQL 缓存依赖项 (VB) |Microsoft 文档"
author: rick-anderson
description: "最简单的缓存策略是时间的允许缓存的数据在指定段后过期。 但是，此简单的方法意味着，缓存的数据 maintai..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 05/30/2007
ms.topic: article
ms.assetid: bd347d93-4251-4532-801c-a36f2dfa7f96
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/data-access/caching-data/using-sql-cache-dependencies-vb
msc.type: authoredcontent
ms.openlocfilehash: 46521f48d31414ffff2707986d6f869ca2f9bc9a
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/10/2017
---
<a name="using-sql-cache-dependencies-vb"></a><span data-ttu-id="0f6bb-104">使用 SQL 缓存依赖项 (VB)</span><span class="sxs-lookup"><span data-stu-id="0f6bb-104">Using SQL Cache Dependencies (VB)</span></span>
====================
<span data-ttu-id="0f6bb-105">通过[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="0f6bb-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="0f6bb-106">[下载代码](http://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_61_VB.zip)或[下载 PDF](using-sql-cache-dependencies-vb/_static/datatutorial61vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="0f6bb-106">[Download Code](http://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_61_VB.zip) or [Download PDF](using-sql-cache-dependencies-vb/_static/datatutorial61vb1.pdf)</span></span>

> <span data-ttu-id="0f6bb-107">最简单的缓存策略是时间的允许缓存的数据在指定段后过期。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-107">The simplest caching strategy is to allow cached data to expire after a specified period of time.</span></span> <span data-ttu-id="0f6bb-108">但是，此简单的方法意味着，缓存的数据要维护对其基础的数据源，从而产生陈旧数据所占用太长或较短时间已过期的当前数据没有关联。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-108">But this simple approach means that the cached data maintains no association with its underlying data source, resulting in stale data that is held too long or current data that is expired too soon.</span></span> <span data-ttu-id="0f6bb-109">更好的方法是使用 SqlCacheDependency 类，以便数据会保留缓存直到其基础数据已修改 SQL 数据库中。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-109">A better approach is to use the SqlCacheDependency class so that data remains cached until its underlying data has been modified in the SQL database.</span></span> <span data-ttu-id="0f6bb-110">此教程演示如何。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-110">This tutorial shows you how.</span></span>


## <a name="introduction"></a><span data-ttu-id="0f6bb-111">介绍</span><span class="sxs-lookup"><span data-stu-id="0f6bb-111">Introduction</span></span>

<span data-ttu-id="0f6bb-112">在检查的缓存技术[ObjectDataSource 与缓存数据](caching-data-with-the-objectdatasource-vb.md)和[体系结构中缓存数据](caching-data-in-the-architecture-vb.md)教程使用基于时间的到期后指定逐出缓存中的数据段。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-112">The caching techniques examined in the [Caching Data with the ObjectDataSource](caching-data-with-the-objectdatasource-vb.md) and [Caching Data in the Architecture](caching-data-in-the-architecture-vb.md) tutorials used a time-based expiry to evict the data from the cache after a specified period.</span></span> <span data-ttu-id="0f6bb-113">这种方法是平衡的缓存数据失效针对性能增益的最简单方法。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-113">This approach is the simplest way to balance the performance gains of caching against data staleness.</span></span> <span data-ttu-id="0f6bb-114">通过选择的时间到期*x* ，秒页开发人员 concedes 以享受仅缓存的性能优势*x*秒，但可以 rest 变得简单，她的数据都不会过时超过最大值*x*秒。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-114">By selecting a time expiry of *x* seconds, a page developer concedes to enjoy the performance benefits of caching for only *x* seconds, but can rest easy that her data will never be stale longer than a maximum of *x* seconds.</span></span> <span data-ttu-id="0f6bb-115">当然，对于静态数据， *x*可以扩展到 web 应用的生存期中，在已检查作为[缓存数据在应用程序启动](caching-data-at-application-startup-vb.md)教程。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-115">Of course, for static data, *x* can be extended to the lifetime of the web application, as was examined in the [Caching Data at Application Startup](caching-data-at-application-startup-vb.md) tutorial.</span></span>

<span data-ttu-id="0f6bb-116">当缓存数据库的数据，基于时间的到期通常选择为其易于使用，但通常是不足的解决方案。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-116">When caching database data, a time-based expiry is often chosen for its ease of use but is frequently an inadequate solution.</span></span> <span data-ttu-id="0f6bb-117">理想情况下，数据库数据将保持缓存之前已修改基础数据中的站点数据库。只有在那时将逐出缓存。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-117">Ideally, the database data would remain cached until the underlying data has been modified in the database; only then would the cache be evicted.</span></span> <span data-ttu-id="0f6bb-118">这种方法最大化缓存的性能优势，并最大程度减少过时的数据的持续时间。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-118">This approach maximizes the performance benefits of caching and minimizes the duration of stale data.</span></span> <span data-ttu-id="0f6bb-119">但是，若要享受这些优势有必须知道基础数据库数据的已修改，且逐出缓存中的相应项目的位置中的某些系统。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-119">However, in order to enjoy these benefits there must be some system in place that knows when the underlying database data has been modified and evicts the corresponding items from the cache.</span></span> <span data-ttu-id="0f6bb-120">在 ASP.NET 2.0 中之前, 页开发人员负责实施此系统。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-120">Prior to ASP.NET 2.0, page developers were responsible for implementing this system.</span></span>

<span data-ttu-id="0f6bb-121">ASP.NET 2.0 提供[`SqlCacheDependency`类](https://msdn.microsoft.com/en-us/library/system.web.caching.sqlcachedependency.aspx)和确定当发生了更改数据库中，以便相应缓存项的必要基础结构可以被逐出。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-121">ASP.NET 2.0 provides a [`SqlCacheDependency` class](https://msdn.microsoft.com/en-us/library/system.web.caching.sqlcachedependency.aspx) and the necessary infrastructure to determine when a change has occurred in the database so that the corresponding cached items can be evicted.</span></span> <span data-ttu-id="0f6bb-122">有两种技术用于确定何时基础数据发生变化： 通知和轮询。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-122">There are two techniques for determining when the underlying data has changed: notification and polling.</span></span> <span data-ttu-id="0f6bb-123">在讨论后通知和轮询之间的差异，我们将创建基础结构支持轮询，然后研究一下如何使用所需`SqlCacheDependency`类中声明性和以编程方式方案。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-123">After discussing the differences between notification and polling, we'll create the infrastructure necessary to support polling and then explore how to use the `SqlCacheDependency` class in declarative and programmatically scenarios.</span></span>

## <a name="understanding-notification-and-polling"></a><span data-ttu-id="0f6bb-124">了解通知和轮询</span><span class="sxs-lookup"><span data-stu-id="0f6bb-124">Understanding Notification and Polling</span></span>

<span data-ttu-id="0f6bb-125">有两种技术可以用于确定数据库中的数据修改时： 通知和轮询。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-125">There are two techniques that can be used to determine when the data in a database has been modified: notification and polling.</span></span> <span data-ttu-id="0f6bb-126">通知，当自上次执行查询以来已更改特定查询的结果后，数据库将自动警报 ASP.NET 运行时，逐出的哪个点与查询关联的缓存的项。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-126">With notification, the database automatically alerts the ASP.NET runtime when the results of a particular query have been changed since the query was last executed, at which point the cached items associated with the query are evicted.</span></span> <span data-ttu-id="0f6bb-127">使用轮询，数据库服务器会维护有关上次更新时间特定的表的信息。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-127">With polling, the database server maintains information about when particular tables have last been updated.</span></span> <span data-ttu-id="0f6bb-128">ASP.NET 运行时定期轮询数据库以检查表已发生的更改因为它们已输入到缓存。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-128">The ASP.NET runtime periodically polls the database to check what tables have changed since they were entered into the cache.</span></span> <span data-ttu-id="0f6bb-129">这些修改其数据的表具有逐出及其关联的缓存项。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-129">Those tables whose data has been modified have their associated cache items evicted.</span></span>

<span data-ttu-id="0f6bb-130">通知选项要求比轮询小于安装程序中，并且由于它跟踪更改在查询级别而不是在表级别更精细。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-130">The notification option requires less setup than polling and is more granular since it tracks changes at the query level rather than at the table level.</span></span> <span data-ttu-id="0f6bb-131">遗憾的是，通知只是完整版本的 Microsoft SQL Server 2005 （即，不是 Express 版本） 中提供的。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-131">Unfortunately, notifications are only available in the full editions of Microsoft SQL Server 2005 (i.e., the non-Express editions).</span></span> <span data-ttu-id="0f6bb-132">但是，轮询选项可以用于从 7.0 的 Microsoft SQL Server 2005 的所有版本。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-132">However, the polling option can be used for all versions of Microsoft SQL Server from 7.0 to 2005.</span></span> <span data-ttu-id="0f6bb-133">由于这些教程使用 SQL Server 2005 Express edition，我们将重点设置和使用轮询选项。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-133">Since these tutorials use the Express edition of SQL Server 2005, we will focus on setting up and using the polling option.</span></span> <span data-ttu-id="0f6bb-134">在本教程针对进一步上 SQL Server 2005 的通知功能的资源的末尾，请查阅进一步读取部分。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-134">Consult the Further Reading section at the end of this tutorial for further resources on SQL Server 2005 s notification capabilities.</span></span>

<span data-ttu-id="0f6bb-135">使用轮询，必须将数据库配置为包括名为的表`AspNet_SqlCacheTablesForChangeNotification`具有三列- `tableName`， `notificationCreated`，和`changeId`。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-135">With polling, the database must be configured to include a table named `AspNet_SqlCacheTablesForChangeNotification` that has three columns - `tableName`, `notificationCreated`, and `changeId`.</span></span> <span data-ttu-id="0f6bb-136">此表包含每个表都有可能需要在 web 应用程序中的 SQL 缓存依赖项中使用的数据行。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-136">This table contains a row for each table that has data that might need to be used in a SQL cache dependency in the web application.</span></span> <span data-ttu-id="0f6bb-137">`tableName`列指定的名称时表`notificationCreated`指示的日期和时间的行已添加到表。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-137">The `tableName` column specifies the name of the table while `notificationCreated` indicates the date and time the row was added to the table.</span></span> <span data-ttu-id="0f6bb-138">`changeId`列的类型是`int`和具有初始值为 0。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-138">The `changeId` column is of type `int` and has an initial value of 0.</span></span> <span data-ttu-id="0f6bb-139">与每一次修改表，其值即会递增。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-139">Its value is incremented with each modification to the table.</span></span>

<span data-ttu-id="0f6bb-140">除了`AspNet_SqlCacheTablesForChangeNotification`表，数据库还需要在每个可能出现的表上的触发器在中包括 SQL 缓存依赖项。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-140">In addition to the `AspNet_SqlCacheTablesForChangeNotification` table, the database also needs to include triggers on each of the tables that may appear in a SQL cache dependency.</span></span> <span data-ttu-id="0f6bb-141">这些触发器执行，而无论插入、 更新或删除行和递增表 s`changeId`中的值`AspNet_SqlCacheTablesForChangeNotification`。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-141">These triggers are executed whenever a row is inserted, updated, or deleted and increment the table s `changeId` value in `AspNet_SqlCacheTablesForChangeNotification`.</span></span>

<span data-ttu-id="0f6bb-142">ASP.NET 运行时跟踪当前`changeId`表缓存数据使用时`SqlCacheDependency`对象。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-142">The ASP.NET runtime tracks the current `changeId` for a table when caching data using a `SqlCacheDependency` object.</span></span> <span data-ttu-id="0f6bb-143">定期检查数据库和任何`SqlCacheDependency`对象其`changeId`不同于数据库中的值不同以来逐出`changeId`值指示已对表的更改数据被缓存后。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-143">The database is periodically checked and any `SqlCacheDependency` objects whose `changeId` differs from the value in the database are evicted since a differing `changeId` value indicates that there has been a change to the table since the data was cached.</span></span>

## <a name="step-1-exploring-theaspnetregsqlexecommand-line-program"></a><span data-ttu-id="0f6bb-144">步骤 1： 浏览`aspnet_regsql.exe`命令行程序</span><span class="sxs-lookup"><span data-stu-id="0f6bb-144">Step 1: Exploring the`aspnet_regsql.exe`Command Line Program</span></span>

<span data-ttu-id="0f6bb-145">数据库必须安装程序以包含上面所述的基础结构使用轮询方法： 预定义的表 (`AspNet_SqlCacheTablesForChangeNotification`)，少量的存储的过程和触发器上每个可能在 web 中的 SQL 缓存依赖关系中使用的表。应用程序。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-145">With the polling approach the database must be setup to contain the infrastructure described above: a predefined table (`AspNet_SqlCacheTablesForChangeNotification`), a handful of stored procedures, and triggers on each of the tables that may be used in SQL cache dependencies in the web application.</span></span> <span data-ttu-id="0f6bb-146">可以通过命令行程序创建这些表、 存储的过程和触发器`aspnet_regsql.exe`，该文件位于`$WINDOWS$\Microsoft.NET\Framework\version`文件夹。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-146">These tables, stored procedures, and triggers can be created through the command line program `aspnet_regsql.exe`, which is found in the `$WINDOWS$\Microsoft.NET\Framework\version` folder.</span></span> <span data-ttu-id="0f6bb-147">若要创建`AspNet_SqlCacheTablesForChangeNotification`表和关联的存储的过程，运行以下命令从命令行：</span><span class="sxs-lookup"><span data-stu-id="0f6bb-147">To create the `AspNet_SqlCacheTablesForChangeNotification` table and associated stored procedures, run the following from the command line:</span></span>


[!code-console[Main](using-sql-cache-dependencies-vb/samples/sample1.cmd)]

> [!NOTE]
> <span data-ttu-id="0f6bb-148">若要执行指定的数据库登录名必须是在这些命令[ `db_securityadmin` ](https://msdn.microsoft.com/en-us/library/ms188685.aspx)和[ `db_ddladmin` ](https://msdn.microsoft.com/en-us/library/ms190667.aspx)角色。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-148">To execute these commands the specified database login must be in the [`db_securityadmin`](https://msdn.microsoft.com/en-us/library/ms188685.aspx) and [`db_ddladmin`](https://msdn.microsoft.com/en-us/library/ms190667.aspx) roles.</span></span> <span data-ttu-id="0f6bb-149">若要检查发送到的数据库 T-SQL`aspnet_regsql.exe`命令行程序，请参阅[此博客文章](http://scottonwriting.net/sowblog/posts/10709.aspx)。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-149">To examine the T-SQL sent to the database by the `aspnet_regsql.exe` command line program, refer to [this blog entry](http://scottonwriting.net/sowblog/posts/10709.aspx).</span></span>


<span data-ttu-id="0f6bb-150">例如，若要向 Microsoft SQL Server 数据库添加轮询的基础结构名为`pubs`名为数据库服务器上`ScottsServer`使用 Windows 身份验证，导航到相应的目录并从命令行中，输入：</span><span class="sxs-lookup"><span data-stu-id="0f6bb-150">For example, to add the infrastructure for polling to a Microsoft SQL Server database named `pubs` on a database server named `ScottsServer` using Windows Authentication, navigate to the appropriate directory and, from the command line, enter:</span></span>


[!code-console[Main](using-sql-cache-dependencies-vb/samples/sample2.cmd)]

<span data-ttu-id="0f6bb-151">已添加的数据库级基础结构后，我们需要将触发器添加到将 SQL 缓存依赖关系中使用这些表。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-151">After the database-level infrastructure has been added, we need to add the triggers to those tables that will be used in SQL cache dependencies.</span></span> <span data-ttu-id="0f6bb-152">使用`aspnet_regsql.exe`命令行程序再次，但指定表名称使用`-t`切换和而不是使用`-ed`切换使用`-et`，如下所示：</span><span class="sxs-lookup"><span data-stu-id="0f6bb-152">Use the `aspnet_regsql.exe` command line program again, but specify the table name using the `-t` switch and instead of using the `-ed` switch use `-et`, like so:</span></span>


[!code-html[Main](using-sql-cache-dependencies-vb/samples/sample3.html)]

<span data-ttu-id="0f6bb-153">若要添加到触发器`authors`和`titles`表上`pubs`上的数据库`ScottsServer`，使用：</span><span class="sxs-lookup"><span data-stu-id="0f6bb-153">To add the triggers to the `authors` and `titles` tables on the `pubs` database on `ScottsServer`, use:</span></span>


[!code-console[Main](using-sql-cache-dependencies-vb/samples/sample4.cmd)]

<span data-ttu-id="0f6bb-154">对于本教程将添加到触发器`Products`， `Categories`，和`Suppliers`表。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-154">For this tutorial add the triggers to the `Products`, `Categories`, and `Suppliers` tables.</span></span> <span data-ttu-id="0f6bb-155">我们将查看步骤 3 中的特定命令行语法。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-155">We'll look at the particular command line syntax in Step 3.</span></span>

## <a name="step-2-referencing-a-microsoft-sql-server-2005-express-edition-database-inappdata"></a><span data-ttu-id="0f6bb-156">步骤 2： 引用中的 Microsoft SQL Server 2005 Express Edition 数据库`App_Data`</span><span class="sxs-lookup"><span data-stu-id="0f6bb-156">Step 2: Referencing a Microsoft SQL Server 2005 Express Edition Database in`App_Data`</span></span>

<span data-ttu-id="0f6bb-157">`aspnet_regsql.exe`命令行程序需要的数据库和服务器名称，以便添加必要的轮询基础结构。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-157">The `aspnet_regsql.exe` command line program requires the database and server name in order to add the necessary polling infrastructure.</span></span> <span data-ttu-id="0f6bb-158">什么是 Microsoft SQL Server 2005 Express 数据库中驻留的数据库和服务器名称，但`App_Data`文件夹？</span><span class="sxs-lookup"><span data-stu-id="0f6bb-158">But what is the database and server name for a Microsoft SQL Server 2005 Express database that resides in the `App_Data` folder?</span></span> <span data-ttu-id="0f6bb-159">而不是无需发现的数据库和服务器名称是什么，我已发现的最简单方法是附加到该数据库`localhost\SQLExpress`数据库实例和重命名数据使用[SQL Server Management Studio](https://msdn.microsoft.com/en-us/library/ms174173.aspx)。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-159">Rather than having to discover what the database and server names are, I ve found that the simplest approach is to attach the database to the `localhost\SQLExpress` database instance and rename the data using [SQL Server Management Studio](https://msdn.microsoft.com/en-us/library/ms174173.aspx).</span></span> <span data-ttu-id="0f6bb-160">如果你有一个在计算机上安装的 SQL Server 2005 的完整版本，然后你很可能已具有在计算机上安装的 SQL Server Management Studio。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-160">If you have one of the full versions of SQL Server 2005 installed on your machine, then you likely already have SQL Server Management Studio installed on your computer.</span></span> <span data-ttu-id="0f6bb-161">如果你只有在 Express 版本，你可以下载免费[Microsoft SQL Server Management Studio Express Edition](https://www.microsoft.com/downloads/details.aspx?displaylang=en&amp;FamilyID=C243A5AE-4BD1-4E3D-94B8-5A0F62BF7796)。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-161">If you only have the Express edition, you can download the free [Microsoft SQL Server Management Studio Express Edition](https://www.microsoft.com/downloads/details.aspx?displaylang=en&amp;FamilyID=C243A5AE-4BD1-4E3D-94B8-5A0F62BF7796).</span></span>

<span data-ttu-id="0f6bb-162">通过关闭 Visual Studio 启动。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-162">Start by closing Visual Studio.</span></span> <span data-ttu-id="0f6bb-163">接下来，打开 SQL Server Management Studio 并选择连接到`localhost\SQLExpress`服务器使用 Windows 身份验证。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-163">Next, open SQL Server Management Studio and choose to connect to the `localhost\SQLExpress` server using Windows Authentication.</span></span>


![将附加到 localhost\SQLExpress 服务器](using-sql-cache-dependencies-vb/_static/image1.gif)

<span data-ttu-id="0f6bb-165">**图 1**： 将附加到`localhost\SQLExpress`服务器</span><span class="sxs-lookup"><span data-stu-id="0f6bb-165">**Figure 1**: Attach to the `localhost\SQLExpress` Server</span></span>


<span data-ttu-id="0f6bb-166">连接到服务器后，Management Studio 将显示服务器并使数据库、 安全性和等的子文件夹。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-166">After connecting to the server, Management Studio will show the server and have subfolders for the databases, security, and so forth.</span></span> <span data-ttu-id="0f6bb-167">右键单击数据库文件夹并选择附加选项。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-167">Right-click on the Databases folder and choose the Attach option.</span></span> <span data-ttu-id="0f6bb-168">此时将显示附加数据库对话框框中 （请参见图 2）。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-168">This will bring up the Attach Databases dialog box (see Figure 2).</span></span> <span data-ttu-id="0f6bb-169">单击添加按钮，然后选择`NORTHWND.MDF`数据库文件夹中你的 web 应用程序 s`App_Data`文件夹。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-169">Click the Add button and select the `NORTHWND.MDF` database folder in your web application s `App_Data` folder.</span></span>


<span data-ttu-id="0f6bb-170">[![将附加 northwnd 不。MDF App_Data 文件夹中的数据库](using-sql-cache-dependencies-vb/_static/image2.gif)](using-sql-cache-dependencies-vb/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="0f6bb-170">[![Attach the NORTHWND.MDF Database from the App_Data Folder](using-sql-cache-dependencies-vb/_static/image2.gif)](using-sql-cache-dependencies-vb/_static/image1.png)</span></span>

<span data-ttu-id="0f6bb-171">**图 2**： 附加`NORTHWND.MDF`数据库从`App_Data`文件夹 ([单击以查看实际尺寸的图像](using-sql-cache-dependencies-vb/_static/image2.png))</span><span class="sxs-lookup"><span data-stu-id="0f6bb-171">**Figure 2**: Attach the `NORTHWND.MDF` Database from the `App_Data` Folder ([Click to view full-size image](using-sql-cache-dependencies-vb/_static/image2.png))</span></span>


<span data-ttu-id="0f6bb-172">这会将数据库添加到数据库文件夹。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-172">This will add the database to the Databases folder.</span></span> <span data-ttu-id="0f6bb-173">数据库名称可能是数据库文件的完整路径或完整路径前面带有[GUID](http://en.wikipedia.org/wiki/Globally_Unique_Identifier)。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-173">The database name might be the full path to the database file or the full path prepended with a [GUID](http://en.wikipedia.org/wiki/Globally_Unique_Identifier).</span></span> <span data-ttu-id="0f6bb-174">为了避免不得不时使用 aspnet 在此时间较长的数据库名称中键入\_regsql.exe 命令行工具、 重命名附加为多用户友好名称，请仅在数据库上右键单击该数据库，然后选择重命名。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-174">To avoid having to type in this lengthy database name when using the aspnet\_regsql.exe command line tool, rename the database to a more human-friendly name by right-clicking on database just attached and choosing Rename.</span></span> <span data-ttu-id="0f6bb-175">我已重我的数据库命名为 DataTutorials。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-175">I ve renamed my database to DataTutorials .</span></span>


![将附加的数据库重命名为多用户友好名称](using-sql-cache-dependencies-vb/_static/image3.gif)

<span data-ttu-id="0f6bb-177">**图 3**： 将附加的数据库重命名为多用户友好名称</span><span class="sxs-lookup"><span data-stu-id="0f6bb-177">**Figure 3**: Rename the Attached Database to a More Human-Friendly Name</span></span>


## <a name="step-3-adding-the-polling-infrastructure-to-the-northwind-database"></a><span data-ttu-id="0f6bb-178">步骤 3： 将轮询基础结构添加到 Northwind 数据库</span><span class="sxs-lookup"><span data-stu-id="0f6bb-178">Step 3: Adding the Polling Infrastructure to the Northwind Database</span></span>

<span data-ttu-id="0f6bb-179">现在，我们已附加`NORTHWND.MDF`数据库从`App_Data`文件夹中，我们重新已准备好添加轮询基础结构。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-179">Now that we have attached the `NORTHWND.MDF` database from the `App_Data` folder, we re ready to add the polling infrastructure.</span></span> <span data-ttu-id="0f6bb-180">假设你已重命名为 DataTutorials 的数据库，运行以下四个命令：</span><span class="sxs-lookup"><span data-stu-id="0f6bb-180">Assuming that you ve renamed the database to DataTutorials, run the following four commands:</span></span>


[!code-console[Main](using-sql-cache-dependencies-vb/samples/sample5.cmd)]

<span data-ttu-id="0f6bb-181">在运行这些四个命令后, 右键单击 Management Studio 中的数据库名称，转到任务子菜单，然后选择分离。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-181">After running these four commands, right-click on the database name in Management Studio, go to the Tasks submenu, and choose Detach.</span></span> <span data-ttu-id="0f6bb-182">然后关闭 Management Studio 并重新打开 Visual Studio。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-182">Then close Management Studio and reopen Visual Studio.</span></span>

<span data-ttu-id="0f6bb-183">后已重新打开 Visual Studio，钻取到通过服务器资源管理器数据库。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-183">Once Visual Studio has reopened, drill into the database through the Server Explorer.</span></span> <span data-ttu-id="0f6bb-184">请注意新的表 (`AspNet_SqlCacheTablesForChangeNotification`)，新存储过程和触发器在`Products`， `Categories`，和`Suppliers`表。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-184">Note the new table (`AspNet_SqlCacheTablesForChangeNotification`), the new stored procedures, and the triggers on the `Products`, `Categories`, and `Suppliers` tables.</span></span>


![数据库现在包括必要的轮询基础结构](using-sql-cache-dependencies-vb/_static/image4.gif)

<span data-ttu-id="0f6bb-186">**图 4**： 数据库现在包括必要的轮询基础结构</span><span class="sxs-lookup"><span data-stu-id="0f6bb-186">**Figure 4**: The Database Now Includes the Necessary Polling Infrastructure</span></span>


## <a name="step-4-configuring-the-polling-service"></a><span data-ttu-id="0f6bb-187">步骤 4： 配置轮询服务</span><span class="sxs-lookup"><span data-stu-id="0f6bb-187">Step 4: Configuring the Polling Service</span></span>

<span data-ttu-id="0f6bb-188">在数据库中创建所需的表、 触发器和存储的过程后, 的最后一步是配置轮询服务，通过完成`Web.config`通过指定以毫秒为单位的数据库迁移到使用和轮询频率。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-188">After creating the needed tables, triggers, and stored procedures in the database, the final step is to configure the polling service, which is done through `Web.config` by specifying the databases to use and the polling frequency in milliseconds.</span></span> <span data-ttu-id="0f6bb-189">以下标记轮询 Northwind 数据库一次每隔一秒。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-189">The following markup polls the Northwind database once every second.</span></span>


[!code-xml[Main](using-sql-cache-dependencies-vb/samples/sample6.xml)]

<span data-ttu-id="0f6bb-190">`name`中的值`<add>`与一个特定的数据库元素 (NorthwindDB) 关联的用户可读名称。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-190">The `name` value in the `<add>` element ( NorthwindDB ) associates a human-readable name with a particular database.</span></span> <span data-ttu-id="0f6bb-191">在使用 SQL 缓存依赖项，我们将需要参考此处定义以及缓存的数据为基础的表的数据库名称。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-191">When working with SQL cache dependencies, we'll need to refer to the database name defined here as well as the table that the cached data is based on.</span></span> <span data-ttu-id="0f6bb-192">我们将了解如何使用`SqlCacheDependency`类以编程方式将与 SQL 缓存依赖项相关联缓存在步骤 6 中的数据。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-192">We'll see how to use the `SqlCacheDependency` class to programmatically associate SQL cache dependencies with cached data in Step 6.</span></span>

<span data-ttu-id="0f6bb-193">轮询系统建立 SQL 缓存依赖项后, 将连接到数据库中定义`<databases>`元素每个`pollTime`毫秒并执行`AspNet_SqlCachePollingStoredProcedure`存储过程。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-193">Once a SQL cache dependency has been established, the polling system will connect to the databases defined in the `<databases>` elements every `pollTime` milliseconds and execute the `AspNet_SqlCachePollingStoredProcedure` stored procedure.</span></span> <span data-ttu-id="0f6bb-194">在步骤 3 中使用此存储的过程-已添加回`aspnet_regsql.exe`命令行工具-返回`tableName`和`changeId`中每个记录的值`AspNet_SqlCacheTablesForChangeNotification`。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-194">This stored procedure - which was added back in Step 3 using the `aspnet_regsql.exe` command line tool - returns the `tableName` and `changeId` values for each record in `AspNet_SqlCacheTablesForChangeNotification`.</span></span> <span data-ttu-id="0f6bb-195">过时的 SQL 缓存依赖项是从缓存中逐出。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-195">Outdated SQL cache dependencies are evicted from the cache.</span></span>

<span data-ttu-id="0f6bb-196">`pollTime`设置引入了性能和数据已过期时间之间的权衡。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-196">The `pollTime` setting introduces a tradeoff between performance and data staleness.</span></span> <span data-ttu-id="0f6bb-197">一个较小`pollTime`值会增加到数据库，请求数，但更多快速逐出缓存中的过时数据。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-197">A small `pollTime` value increases the number of requests to the database, but more quickly evicts stale data from the cache.</span></span> <span data-ttu-id="0f6bb-198">更大`pollTime`值将减少数据库请求数，但会增加后端数据的更改时和时逐出相关的缓存项之间的延迟。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-198">A larger `pollTime` value reduces the number of database requests, but increases the delay between when the backend data changes and when the related cache items are evicted.</span></span> <span data-ttu-id="0f6bb-199">幸运的，数据库请求正在执行简单的存储的过程从简单的轻型表返回只需几行该 s。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-199">Fortunately, the database request is executing a simple stored procedure that s returning just a few rows from a simple, lightweight table.</span></span> <span data-ttu-id="0f6bb-200">但执行试验不同`pollTime`值来查找之间找到一个理想的平衡点数据库应用程序的访问和数据过期时间。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-200">But do experiment with different `pollTime` values to find an ideal balance between database access and data staleness for your application.</span></span> <span data-ttu-id="0f6bb-201">最小`pollTime`允许的值为 500。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-201">The smallest `pollTime` value allowed is 500.</span></span>

> [!NOTE]
> <span data-ttu-id="0f6bb-202">上面的示例中提供单个`pollTime`中的值`<sqlCacheDependency>`元素，但是你可以选择指定`pollTime`中的值`<add>`元素。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-202">The above example provides a single `pollTime` value in the `<sqlCacheDependency>` element, but you can optionally specify the `pollTime` value in the `<add>` element.</span></span> <span data-ttu-id="0f6bb-203">如果你有多个指定的数据库并想要自定义每个数据库的轮询频率，这非常有用。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-203">This is useful if you have multiple databases specified and want to customize the polling frequency per database.</span></span>


## <a name="step-5-declaratively-working-with-sql-cache-dependencies"></a><span data-ttu-id="0f6bb-204">步骤 5： 以声明方式使用 SQL 缓存依赖项</span><span class="sxs-lookup"><span data-stu-id="0f6bb-204">Step 5: Declaratively Working with SQL Cache Dependencies</span></span>

<span data-ttu-id="0f6bb-205">在步骤 1 至 4 我们介绍了如何设置必要的数据库基础结构和配置轮询系统。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-205">In Steps 1 through 4 we looked at how to setup the necessary database infrastructure and configure the polling system.</span></span> <span data-ttu-id="0f6bb-206">与此基础结构，我们现在可以添加项到数据缓存与使用编程或声明性技术关联 SQL 缓存依赖项。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-206">With this infrastructure in place, we can now add items to the data cache with an associated SQL cache dependency using either programmatic or declarative techniques.</span></span> <span data-ttu-id="0f6bb-207">在此步骤中，我们将查看如何以声明方式使用 SQL 缓存依赖项。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-207">In this step we'll examine how to declaratively work with SQL cache dependencies.</span></span> <span data-ttu-id="0f6bb-208">在步骤 6 中，我们将看编程的方式。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-208">In Step 6 we'll look at the programmatic approach.</span></span>

<span data-ttu-id="0f6bb-209">[缓存数据与 ObjectDataSource](caching-data-with-the-objectdatasource-vb.md)教程介绍了 ObjectDataSource 的声明性缓存功能。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-209">The [Caching Data with the ObjectDataSource](caching-data-with-the-objectdatasource-vb.md) tutorial explored the declarative caching capabilities of the ObjectDataSource.</span></span> <span data-ttu-id="0f6bb-210">通过只需设置`EnableCaching`属性`True`和`CacheDuration`到某些时间间隔的属性，ObjectDataSource 自动将缓存达到指定间隔从其基础对象返回的数据。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-210">By simply setting the `EnableCaching` property to `True` and the `CacheDuration` property to some time interval, the ObjectDataSource will automatically cache the data returned from its underlying object for the specified interval.</span></span> <span data-ttu-id="0f6bb-211">ObjectDataSource 还可以使用一个或多个 SQL 缓存依赖项。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-211">The ObjectDataSource can also use one or more SQL cache dependencies.</span></span>

<span data-ttu-id="0f6bb-212">若要演示如何以声明方式使用 SQL 缓存依赖项，打开`SqlCacheDependencies.aspx`页面`Caching`文件夹，然后拖动一个 GridView 从工具箱中拖动到设计器。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-212">To demonstrate using SQL cache dependencies declaratively, open the `SqlCacheDependencies.aspx` page in the `Caching` folder and drag a GridView from the Toolbox onto the Designer.</span></span> <span data-ttu-id="0f6bb-213">设置 GridView s`ID`到`ProductsDeclarative`和从其智能标记上，选择要绑定到名为新 ObjectDataSource `ProductsDataSourceDeclarative`。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-213">Set the GridView s `ID` to `ProductsDeclarative` and, from its smart tag, choose to bind it to a new ObjectDataSource named `ProductsDataSourceDeclarative`.</span></span>


<span data-ttu-id="0f6bb-214">[![创建名为 ProductsDataSourceDeclarative 新对象数据源](using-sql-cache-dependencies-vb/_static/image5.gif)](using-sql-cache-dependencies-vb/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="0f6bb-214">[![Create a New ObjectDataSource Named ProductsDataSourceDeclarative](using-sql-cache-dependencies-vb/_static/image5.gif)](using-sql-cache-dependencies-vb/_static/image3.png)</span></span>

<span data-ttu-id="0f6bb-215">**图 5**： 创建新对象数据源命名`ProductsDataSourceDeclarative`([单击以查看实际尺寸的图像](using-sql-cache-dependencies-vb/_static/image4.png))</span><span class="sxs-lookup"><span data-stu-id="0f6bb-215">**Figure 5**: Create a New ObjectDataSource Named `ProductsDataSourceDeclarative` ([Click to view full-size image](using-sql-cache-dependencies-vb/_static/image4.png))</span></span>


<span data-ttu-id="0f6bb-216">配置对象数据源以使用`ProductsBLL`类，然后在选择选项卡中设置下拉列表`GetProducts()`。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-216">Configure the ObjectDataSource to use the `ProductsBLL` class and set the drop-down list in the SELECT tab to `GetProducts()`.</span></span> <span data-ttu-id="0f6bb-217">在更新选项卡，选择`UpdateProduct`带有三个输入参数的重载`productName`， `unitPrice`，和`productID`。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-217">In the UPDATE tab, choose the `UpdateProduct` overload with three input parameters - `productName`, `unitPrice`, and `productID`.</span></span> <span data-ttu-id="0f6bb-218">在 INSERT 和 DELETE 选项卡中设置下拉列表中的，以便 （无）。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-218">Set the drop-down lists to (None) in the INSERT and DELETE tabs.</span></span>


<span data-ttu-id="0f6bb-219">[![使用带有三个输入参数的 UpdateProduct 重载](using-sql-cache-dependencies-vb/_static/image6.gif)](using-sql-cache-dependencies-vb/_static/image5.png)</span><span class="sxs-lookup"><span data-stu-id="0f6bb-219">[![Use the UpdateProduct Overload with Three Input Parameters](using-sql-cache-dependencies-vb/_static/image6.gif)](using-sql-cache-dependencies-vb/_static/image5.png)</span></span>

<span data-ttu-id="0f6bb-220">**图 6**： 带有三个输入参数使用 UpdateProduct 重载 ([单击以查看实际尺寸的图像](using-sql-cache-dependencies-vb/_static/image6.png))</span><span class="sxs-lookup"><span data-stu-id="0f6bb-220">**Figure 6**: Use the UpdateProduct Overload with Three Input Parameters ([Click to view full-size image](using-sql-cache-dependencies-vb/_static/image6.png))</span></span>


<span data-ttu-id="0f6bb-221">[![设置为 (None) 对插入和删除选项卡的下拉列表](using-sql-cache-dependencies-vb/_static/image7.gif)](using-sql-cache-dependencies-vb/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="0f6bb-221">[![Set the Drop-Down List to (None) for the INSERT and DELETE Tabs](using-sql-cache-dependencies-vb/_static/image7.gif)](using-sql-cache-dependencies-vb/_static/image7.png)</span></span>

<span data-ttu-id="0f6bb-222">**图 7**： 对插入和删除选项卡设置为 (None) 的下拉列表 ([单击以查看实际尺寸的图像](using-sql-cache-dependencies-vb/_static/image8.png))</span><span class="sxs-lookup"><span data-stu-id="0f6bb-222">**Figure 7**: Set the Drop-Down List to (None) for the INSERT and DELETE Tabs ([Click to view full-size image](using-sql-cache-dependencies-vb/_static/image8.png))</span></span>


<span data-ttu-id="0f6bb-223">完成配置数据源向导后，Visual Studio 将 BoundFields 内创建和 CheckBoxFields GridView 为每个数据字段。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-223">After completing the Configure Data Source wizard, Visual Studio will create BoundFields and CheckBoxFields in the GridView for each of the data fields.</span></span> <span data-ttu-id="0f6bb-224">删除所有字段，但`ProductName`， `CategoryName`，和`UnitPrice`，并根据你的设置这些字段的格式。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-224">Remove all fields but `ProductName`, `CategoryName`, and `UnitPrice`, and format these fields as you see fit.</span></span> <span data-ttu-id="0f6bb-225">从 GridView s 智能标记，选中启用分页、 启用排序和启用编辑复选框。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-225">From the GridView s smart tag, check the Enable Paging, Enable Sorting, and Enable Editing checkboxes.</span></span> <span data-ttu-id="0f6bb-226">Visual Studio 将设置 ObjectDataSource s`OldValuesParameterFormatString`属性`original_{0}`。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-226">Visual Studio will set the ObjectDataSource s `OldValuesParameterFormatString` property to `original_{0}`.</span></span> <span data-ttu-id="0f6bb-227">或者可以使 GridView 的编辑功能，使其正常工作，来移除完全从的声明性语法或集回其默认值，此属性`{0}`。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-227">In order for the GridView s edit feature to work properly, either remove this property entirely from the declarative syntax or set it back to its default value, `{0}`.</span></span>

<span data-ttu-id="0f6bb-228">最后，添加到的 GridView 和集上方标签 Web 控件其`ID`属性`ODSEvents`及其`EnableViewState`属性`False`。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-228">Finally, add a Label Web control above the GridView and set its `ID` property to `ODSEvents` and its `EnableViewState` property to `False`.</span></span> <span data-ttu-id="0f6bb-229">进行这些更改后，你页面 s 声明性标记应类似于以下。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-229">After making these changes, your page s declarative markup should look similar to the following.</span></span> <span data-ttu-id="0f6bb-230">请注意，已进行了一些的审美自定义项，则不需要为了演示 SQL 缓存依赖项功能的 GridView 字段。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-230">Note that I ve made a number of aesthetic customizations to the GridView fields that are not necessary to demonstrate the SQL cache dependency functionality.</span></span>


[!code-aspx[Main](using-sql-cache-dependencies-vb/samples/sample7.aspx)]

<span data-ttu-id="0f6bb-231">接下来，创建的事件处理程序 ObjectDataSource 的`Selecting`事件并在它中添加以下代码：</span><span class="sxs-lookup"><span data-stu-id="0f6bb-231">Next, create an event handler for the ObjectDataSource s `Selecting` event and in it add the following code:</span></span>


[!code-vb[Main](using-sql-cache-dependencies-vb/samples/sample8.vb)]

<span data-ttu-id="0f6bb-232">回想一下，ObjectDataSource 的`Selecting`仅从其基础对象检索数据时，事件将激发。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-232">Recall that the ObjectDataSource s `Selecting` event fires only when retrieving data from its underlying object.</span></span> <span data-ttu-id="0f6bb-233">如果 ObjectDataSource 从其自己的缓存访问数据，不激发此事件。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-233">If the ObjectDataSource accesses the data from its own cache, this event is not fired.</span></span>

<span data-ttu-id="0f6bb-234">现在，请访问此页面通过浏览器。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-234">Now, visit this page through a browser.</span></span> <span data-ttu-id="0f6bb-235">因为我们遇到有待实现任何缓存，每次页上，进行排序，或编辑的网格页应显示文本，选择事件激发，如图 8 所示。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-235">Since we ve yet to implement any caching, each time you page, sort, or edit the grid the page should display the text, �Selecting event fired, as Figure 8 shows.</span></span>


<span data-ttu-id="0f6bb-236">[![ObjectDataSource 的选择事件激发每个时间分页 GridView，编辑或 Sorted](using-sql-cache-dependencies-vb/_static/image8.gif)](using-sql-cache-dependencies-vb/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="0f6bb-236">[![The ObjectDataSource s Selecting Event Fires Each Time the GridView is Paged, Edited, or Sorted](using-sql-cache-dependencies-vb/_static/image8.gif)](using-sql-cache-dependencies-vb/_static/image9.png)</span></span>

<span data-ttu-id="0f6bb-237">**图 8**: ObjectDataSource s`Selecting`事件将触发每个时间分页 GridView、 编辑或 Sorted ([单击以查看实际尺寸的图像](using-sql-cache-dependencies-vb/_static/image10.png))</span><span class="sxs-lookup"><span data-stu-id="0f6bb-237">**Figure 8**: The ObjectDataSource s `Selecting` Event Fires Each Time the GridView is Paged, Edited, or Sorted ([Click to view full-size image](using-sql-cache-dependencies-vb/_static/image10.png))</span></span>


<span data-ttu-id="0f6bb-238">正如我们看到在[ObjectDataSource 与缓存数据](caching-data-with-the-objectdatasource-vb.md)教程中，设置`EnableCaching`属性`True`ObjectDataSource 由指定的持续时间的缓存其数据将导致其`CacheDuration`属性。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-238">As we saw in the [Caching Data with the ObjectDataSource](caching-data-with-the-objectdatasource-vb.md) tutorial, setting the `EnableCaching` property to `True` causes the ObjectDataSource to cache its data for the duration specified by its `CacheDuration` property.</span></span> <span data-ttu-id="0f6bb-239">ObjectDataSource 还有[`SqlCacheDependency`属性](https://msdn.microsoft.com/en-us/library/system.web.ui.webcontrols.objectdatasource.sqlcachedependency.aspx)，从而将一个或多个 SQL 缓存依赖项添加到缓存的数据使用模式：</span><span class="sxs-lookup"><span data-stu-id="0f6bb-239">The ObjectDataSource also has a [`SqlCacheDependency` property](https://msdn.microsoft.com/en-us/library/system.web.ui.webcontrols.objectdatasource.sqlcachedependency.aspx), which adds one or more SQL cache dependencies to the cached data using the pattern:</span></span>


[!code-css[Main](using-sql-cache-dependencies-vb/samples/sample9.css)]

<span data-ttu-id="0f6bb-240">其中*databaseName*是作为中指定的数据库的名称`name`属性`<add>`中的元素`Web.config`，和*tableName*是数据库表的名称。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-240">Where *databaseName* is the name of the database as specified in the `name` attribute of the `<add>` element in `Web.config`, and *tableName* is the name of the database table.</span></span> <span data-ttu-id="0f6bb-241">例如，若要创建无限期地缓存数据 ObjectDataSource 基于 SQL 缓存依赖项针对 Northwind s`Products`表中，设置 ObjectDataSource s`EnableCaching`属性`True`及其`SqlCacheDependency`属性NorthwindDB:Products。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-241">For example, to create an ObjectDataSource that caches data indefinitely based on a SQL cache dependency against the Northwind s `Products` table, set the ObjectDataSource s `EnableCaching` property to `True` and its `SqlCacheDependency` property to NorthwindDB:Products .</span></span>

> [!NOTE]
> <span data-ttu-id="0f6bb-242">你可以使用 SQL 缓存依赖项*和*通过设置基于时间的到期`EnableCaching`到`True`，`CacheDuration`为时间间隔中，和`SqlCacheDependency`对数据库和表名。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-242">You can use a SQL cache dependency *and* a time-based expiry by setting `EnableCaching` to `True`, `CacheDuration` to the time interval, and `SqlCacheDependency` to the database and table name(s).</span></span> <span data-ttu-id="0f6bb-243">当达到基于时间的到期时或当轮询系统会注意，基础数据库数据已更改，以先发生者为准，ObjectDataSource 将逐出其数据。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-243">The ObjectDataSource will evict its data when the time-based expiry is reached or when the polling system notes that the underlying database data has changed, whichever happens first.</span></span>


<span data-ttu-id="0f6bb-244">在 GridView`SqlCacheDependencies.aspx`显示从两个表的数据`Products`和`Categories`(产品 s`CategoryName`字段检索通过`JOIN`上`Categories`)。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-244">The GridView in `SqlCacheDependencies.aspx` displays data from two tables - `Products` and `Categories` (the product s `CategoryName` field is retrieved via a `JOIN` on `Categories`).</span></span> <span data-ttu-id="0f6bb-245">因此，我们想要指定两个 SQL 缓存依赖项： NorthwindDB:Products;NorthwindDB:Categories。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-245">Therefore, we want to specify two SQL cache dependencies: NorthwindDB:Products;NorthwindDB:Categories .</span></span>


<span data-ttu-id="0f6bb-246">[![配置对象数据源以支持缓存产品和类别上使用 SQL 缓存依赖项](using-sql-cache-dependencies-vb/_static/image9.gif)](using-sql-cache-dependencies-vb/_static/image11.png)</span><span class="sxs-lookup"><span data-stu-id="0f6bb-246">[![Configure the ObjectDataSource to Support Caching Using SQL Cache Dependencies on Products and Categories](using-sql-cache-dependencies-vb/_static/image9.gif)](using-sql-cache-dependencies-vb/_static/image11.png)</span></span>

<span data-ttu-id="0f6bb-247">**图 9**： 上配置支持缓存使用 SQL 缓存依赖项 ObjectDataSource`Products`和`Categories`([单击以查看实际尺寸的图像](using-sql-cache-dependencies-vb/_static/image12.png))</span><span class="sxs-lookup"><span data-stu-id="0f6bb-247">**Figure 9**: Configure the ObjectDataSource to Support Caching Using SQL Cache Dependencies on `Products` and `Categories` ([Click to view full-size image](using-sql-cache-dependencies-vb/_static/image12.png))</span></span>


<span data-ttu-id="0f6bb-248">在配置对象数据源以支持缓存之后, 重新访问通过浏览器页面。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-248">After configuring the ObjectDataSource to support caching, revisit the page through a browser.</span></span> <span data-ttu-id="0f6bb-249">同样，激发的文本选择事件应显示在第一次的页访问，但应消失时分页、 排序，或单击编辑或取消按钮。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-249">Again, the text �Selecting event fired should appear on the first page visit, but should go away when paging, sorting, or clicking the Edit or Cancel buttons.</span></span> <span data-ttu-id="0f6bb-250">这是因为数据加载到 ObjectDataSource 的缓存之后，它将一直存在直到`Products`或`Categories`修改表或数据通过 GridView 进行了更新。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-250">This is because after the data is loaded into the ObjectDataSource s cache, it remains there until the `Products` or `Categories` tables are modified or the data is updated through the GridView.</span></span>

<span data-ttu-id="0f6bb-251">沿网格分页，并记下在缺乏选择事件触发后文本，打开新的浏览器窗口并导航到编辑，插入和删除部分中的基础知识教程 (`~/EditInsertDelete/Basics.aspx`)。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-251">After paging through the grid and noting the lack of the �Selecting event fired text, open a new browser window and navigate to the Basics tutorial in the Editing, Inserting, and Deleting section (`~/EditInsertDelete/Basics.aspx`).</span></span> <span data-ttu-id="0f6bb-252">更新的名称或产品价格。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-252">Update the name or price of a product.</span></span> <span data-ttu-id="0f6bb-253">然后，从第一个浏览器窗口中，查看不同的页面的数据，排序网格中，或单击行的编辑按钮。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-253">Then, from to the first browser window, view a different page of data, sort the grid, or click a row s Edit button.</span></span> <span data-ttu-id="0f6bb-254">这一次，选择事件激发应重新出现，如基础数据库数据已被修改 （请参阅图 10）。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-254">This time, the �Selecting event fired should reappear, as the underlying database data has been modified (see Figure 10).</span></span> <span data-ttu-id="0f6bb-255">如果文本不出现，请稍等片刻，然后重试。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-255">If the text does not appear, wait a few moments and try again.</span></span> <span data-ttu-id="0f6bb-256">请记住，轮询服务正在检查的更改`Products`表每个`pollTime`毫秒，而没有更新基础数据时和时逐出缓存的数据之间的延迟。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-256">Remember that the polling service is checking for changes to the `Products` table every `pollTime` milliseconds, so there is a delay between when the underlying data is updated and when the cached data is evicted.</span></span>


<span data-ttu-id="0f6bb-257">[![修改 Products 表逐出缓存的产品数据](using-sql-cache-dependencies-vb/_static/image10.gif)](using-sql-cache-dependencies-vb/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="0f6bb-257">[![Modifying the Products Table Evicts the Cached Product Data](using-sql-cache-dependencies-vb/_static/image10.gif)](using-sql-cache-dependencies-vb/_static/image13.png)</span></span>

<span data-ttu-id="0f6bb-258">**图 10**： 修改产品表逐出缓存产品数据 ([单击以查看实际尺寸的图像](using-sql-cache-dependencies-vb/_static/image14.png))</span><span class="sxs-lookup"><span data-stu-id="0f6bb-258">**Figure 10**: Modifying the Products Table Evicts the Cached Product Data ([Click to view full-size image](using-sql-cache-dependencies-vb/_static/image14.png))</span></span>


## <a name="step-6-programmatically-working-with-thesqlcachedependencyclass"></a><span data-ttu-id="0f6bb-259">步骤 6： 以编程方式使用`SqlCacheDependency`类</span><span class="sxs-lookup"><span data-stu-id="0f6bb-259">Step 6: Programmatically Working with the`SqlCacheDependency`Class</span></span>

<span data-ttu-id="0f6bb-260">[体系结构中缓存数据](caching-data-in-the-architecture-vb.md)教程看而不是紧密耦合 ObjectDataSource 缓存的体系结构中使用单独的缓存层的好处。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-260">The [Caching Data in the Architecture](caching-data-in-the-architecture-vb.md) tutorial looked at the benefits of using a separate Caching Layer in the architecture as opposed to tightly coupling the caching with the ObjectDataSource.</span></span> <span data-ttu-id="0f6bb-261">在该教程中，我们将创建`ProductsCL`类，以演示如何以编程方式使用数据缓存。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-261">In that tutorial we created a `ProductsCL` class to demonstrate programmatically working with the data cache.</span></span> <span data-ttu-id="0f6bb-262">若要利用缓存层中的 SQL 缓存依赖项，使用`SqlCacheDependency`类。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-262">To utilize SQL cache dependencies in the Caching Layer, use the `SqlCacheDependency` class.</span></span>

<span data-ttu-id="0f6bb-263">使用轮询系统`SqlCacheDependency`对象必须与一个特定的数据库和表对相关联。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-263">With the polling system, a `SqlCacheDependency` object must be associated with a particular database and table pair.</span></span> <span data-ttu-id="0f6bb-264">下面的代码，例如，创建`SqlCacheDependency`对象基于 Northwind 数据库的`Products`表：</span><span class="sxs-lookup"><span data-stu-id="0f6bb-264">The following code, for example, creates a `SqlCacheDependency` object based on the Northwind database s `Products` table:</span></span>


[!code-vb[Main](using-sql-cache-dependencies-vb/samples/sample10.vb)]

<span data-ttu-id="0f6bb-265">两个输入参数为`SqlCacheDependency`s 构造函数将分别为数据库和表名称。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-265">The two input parameters to the `SqlCacheDependency` s constructor are the database and table names, respectively.</span></span> <span data-ttu-id="0f6bb-266">与 ObjectDataSource s 类似`SqlCacheDependency`属性，使用的数据库名称是中指定的值相同`name`属性`<add>`中的元素`Web.config`。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-266">Like with the ObjectDataSource s `SqlCacheDependency` property, the database name used is the same as the value specified in the `name` attribute of the `<add>` element in `Web.config`.</span></span> <span data-ttu-id="0f6bb-267">表名是数据库表的实际名称。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-267">The table name is the actual name of the database table.</span></span>

<span data-ttu-id="0f6bb-268">若要将关联`SqlCacheDependency`与添加到数据缓存的项，请使用之一`Insert`接受依赖关系的方法重载。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-268">To associate a `SqlCacheDependency` with an item added to the data cache, use one of the `Insert` method overloads that accepts a dependency.</span></span> <span data-ttu-id="0f6bb-269">下面的代码添加*值*到数据缓存中用于无限期的持续时间，但将其关联与`SqlCacheDependency`上`Products`表。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-269">The following code adds *value* to the data cache for an indefinite duration, but associates it with a `SqlCacheDependency` on the `Products` table.</span></span> <span data-ttu-id="0f6bb-270">简单地说，*值*将保留在缓存中，直到逐出由于内存约束，或者由于轮询系统已检测到`Products`表已更改自缓存。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-270">In short, *value* will remain in the cache until it is evicted due to memory constraints or because the polling system has detected that the `Products` table has changed since it was cached.</span></span>


[!code-vb[Main](using-sql-cache-dependencies-vb/samples/sample11.vb)]

<span data-ttu-id="0f6bb-271">缓存层 s`ProductsCL`类当前缓存中的数据`Products`表使用 60 秒的基于时间的到期。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-271">The Caching Layer s `ProductsCL` class currently caches data from the `Products` table using a time-based expiry of 60 seconds.</span></span> <span data-ttu-id="0f6bb-272">让我们来更新此类，以便它改为使用 SQL 缓存依赖项。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-272">Let s update this class so that it uses SQL cache dependencies instead.</span></span> <span data-ttu-id="0f6bb-273">`ProductsCL`类的`AddCacheItem`方法，负责将数据添加到缓存，当前包含以下代码：</span><span class="sxs-lookup"><span data-stu-id="0f6bb-273">The `ProductsCL` class s `AddCacheItem` method, which is responsible for adding the data to the cache, currently contains the following code:</span></span>


[!code-vb[Main](using-sql-cache-dependencies-vb/samples/sample12.vb)]

<span data-ttu-id="0f6bb-274">更新此代码以使用`SqlCacheDependency`对象而不是`MasterCacheKeyArray`缓存依赖项：</span><span class="sxs-lookup"><span data-stu-id="0f6bb-274">Update this code to use a `SqlCacheDependency` object instead of the `MasterCacheKeyArray` cache dependency:</span></span>


[!code-vb[Main](using-sql-cache-dependencies-vb/samples/sample13.vb)]

<span data-ttu-id="0f6bb-275">若要测试此功能，向下现有页面添加一个 GridView `ProductsDeclarative` GridView。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-275">To test this functionality, add a GridView to the page beneath the existing `ProductsDeclarative` GridView.</span></span> <span data-ttu-id="0f6bb-276">设置此新的 GridView s`ID`到`ProductsProgrammatic`并通过其智能标记，请将其绑定到名为新 ObjectDataSource `ProductsDataSourceProgrammatic`。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-276">Set this new GridView s `ID` to `ProductsProgrammatic` and, through its smart tag, bind it to a new ObjectDataSource named `ProductsDataSourceProgrammatic`.</span></span> <span data-ttu-id="0f6bb-277">配置对象数据源以使用`ProductsCL`类，设置的下拉列表中选择和更新选项卡添加到`GetProducts`和`UpdateProduct`分别。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-277">Configure the ObjectDataSource to use the `ProductsCL` class, setting the drop-down lists in the SELECT and UPDATE tabs to `GetProducts` and `UpdateProduct`, respectively.</span></span>


<span data-ttu-id="0f6bb-278">[![配置对象数据源以使用 ProductsCL 类](using-sql-cache-dependencies-vb/_static/image11.gif)](using-sql-cache-dependencies-vb/_static/image15.png)</span><span class="sxs-lookup"><span data-stu-id="0f6bb-278">[![Configure the ObjectDataSource to Use the ProductsCL Class](using-sql-cache-dependencies-vb/_static/image11.gif)](using-sql-cache-dependencies-vb/_static/image15.png)</span></span>

<span data-ttu-id="0f6bb-279">**图 11**： 配置使用 ObjectDataSource`ProductsCL`类 ([单击以查看实际尺寸的图像](using-sql-cache-dependencies-vb/_static/image16.png))</span><span class="sxs-lookup"><span data-stu-id="0f6bb-279">**Figure 11**: Configure the ObjectDataSource to Use the `ProductsCL` Class ([Click to view full-size image](using-sql-cache-dependencies-vb/_static/image16.png))</span></span>


<span data-ttu-id="0f6bb-280">[![从选择选项卡上的下拉列表中选择 GetProducts 方法](using-sql-cache-dependencies-vb/_static/image12.gif)](using-sql-cache-dependencies-vb/_static/image17.png)</span><span class="sxs-lookup"><span data-stu-id="0f6bb-280">[![Select the GetProducts Method from the SELECT Tab s Drop-Down List](using-sql-cache-dependencies-vb/_static/image12.gif)](using-sql-cache-dependencies-vb/_static/image17.png)</span></span>

<span data-ttu-id="0f6bb-281">**图 12**： 选择`GetProducts`从选择的选项卡 s 下拉列表的方法 ([单击以查看实际尺寸的图像](using-sql-cache-dependencies-vb/_static/image18.png))</span><span class="sxs-lookup"><span data-stu-id="0f6bb-281">**Figure 12**: Select the `GetProducts` Method from the SELECT Tab s Drop-Down List ([Click to view full-size image](using-sql-cache-dependencies-vb/_static/image18.png))</span></span>


<span data-ttu-id="0f6bb-282">[![从更新选项卡的下拉列表中选择 UpdateProduct 方法](using-sql-cache-dependencies-vb/_static/image13.gif)](using-sql-cache-dependencies-vb/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="0f6bb-282">[![Choose the UpdateProduct Method from the UPDATE Tab s Drop-Down List](using-sql-cache-dependencies-vb/_static/image13.gif)](using-sql-cache-dependencies-vb/_static/image19.png)</span></span>

<span data-ttu-id="0f6bb-283">**图 13**： 从更新选项卡的下拉列表中选择 UpdateProduct 方法 ([单击以查看实际尺寸的图像](using-sql-cache-dependencies-vb/_static/image20.png))</span><span class="sxs-lookup"><span data-stu-id="0f6bb-283">**Figure 13**: Choose the UpdateProduct Method from the UPDATE Tab s Drop-Down List ([Click to view full-size image](using-sql-cache-dependencies-vb/_static/image20.png))</span></span>


<span data-ttu-id="0f6bb-284">完成配置数据源向导后，Visual Studio 将 BoundFields 内创建和 CheckBoxFields GridView 为每个数据字段。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-284">After completing the Configure Data Source wizard, Visual Studio will create BoundFields and CheckBoxFields in the GridView for each of the data fields.</span></span> <span data-ttu-id="0f6bb-285">如与第一个 GridView 添加到此页上，删除所有字段，但`ProductName`， `CategoryName`，和`UnitPrice`，并根据你的设置这些字段的格式。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-285">Like with the first GridView added to this page, remove all fields but `ProductName`, `CategoryName`, and `UnitPrice`, and format these fields as you see fit.</span></span> <span data-ttu-id="0f6bb-286">从 GridView s 智能标记，选中启用分页、 启用排序和启用编辑复选框。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-286">From the GridView s smart tag, check the Enable Paging, Enable Sorting, and Enable Editing checkboxes.</span></span> <span data-ttu-id="0f6bb-287">与`ProductsDataSourceDeclarative`ObjectDataSource，Visual Studio 将设置`ProductsDataSourceProgrammatic`ObjectDataSource s`OldValuesParameterFormatString`属性`original_{0}`。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-287">As with the `ProductsDataSourceDeclarative` ObjectDataSource, Visual Studio will set the `ProductsDataSourceProgrammatic` ObjectDataSource s `OldValuesParameterFormatString` property to `original_{0}`.</span></span> <span data-ttu-id="0f6bb-288">为了使 GridView 的编辑功能，若要正常工作，请将此属性设置回`{0}`（或完全声明性语法中删除属性赋值）。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-288">In order for the GridView s edit feature to work properly, set this property back to `{0}` (or remove the property assignment from the declarative syntax altogether).</span></span>

<span data-ttu-id="0f6bb-289">完成这些任务之后，生成的 GridView 和 ObjectDataSource 声明性标记应如下所示：</span><span class="sxs-lookup"><span data-stu-id="0f6bb-289">After completing these tasks, the resulting GridView and ObjectDataSource declarative markup should look like the following:</span></span>


[!code-aspx[Main](using-sql-cache-dependencies-vb/samples/sample14.aspx)]

<span data-ttu-id="0f6bb-290">若要测试 SQL 缓存层中的缓存依赖项中设置断点`ProductCL`类的`AddCacheItem`方法，然后开始调试。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-290">To test the SQL cache dependency in the Caching Layer set a breakpoint in the `ProductCL` class s `AddCacheItem` method and then start debugging.</span></span> <span data-ttu-id="0f6bb-291">当你首次访问`SqlCacheDependencies.aspx`，应会命中断点，作为第一次请求数据并将其放入缓存。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-291">When you first visit `SqlCacheDependencies.aspx`, the breakpoint should be hit as the data is requested for the first time and placed into the cache.</span></span> <span data-ttu-id="0f6bb-292">接下来，将移动到 GridView 的另一页或排序的列之一。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-292">Next, move to another page in the GridView or sort one of the columns.</span></span> <span data-ttu-id="0f6bb-293">这将导致 GridView 类型重新查询其数据，但应以来在缓存中找到数据`Products`尚未修改数据库表。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-293">This causes the GridView to requery its data, but the data should be found in the cache since the `Products` database table has not been modified.</span></span> <span data-ttu-id="0f6bb-294">如果反复不在缓存中找到的数据，请确保有足够的内存可用在你的计算机上，然后重试。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-294">If the data is repeatedly not found in the cache, make sure there is sufficient memory available on your computer and try again.</span></span>

<span data-ttu-id="0f6bb-295">后到的 GridView 的几个页面的分页，打开第二个浏览器窗口并导航到编辑，插入和删除部分中的基础知识教程 (`~/EditInsertDelete/Basics.aspx`)。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-295">After paging through a few pages of the GridView, open a second browser window and navigate to the Basics tutorial in the Editing, Inserting, and Deleting section (`~/EditInsertDelete/Basics.aspx`).</span></span> <span data-ttu-id="0f6bb-296">更新来自产品表的记录，然后，从第一个浏览器窗口中，查看新的页或单击其中一个排序的标头。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-296">Update a record from the Products table and then, from the first browser window, view a new page or click on one of the sorting headers.</span></span>

<span data-ttu-id="0f6bb-297">在这种情况下你将看到以下两项操作之一： 任一断点将被命中，，该值指示缓存的数据已被逐出由于数据库; 中更改或者，将不会命中断点，这意味着，`SqlCacheDependencies.aspx`现在显示过时的数据。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-297">In this scenario you will see one of two things: either the breakpoint will be hit, indicating that the cached data was evicted due to the change in the database; or, the breakpoint will not be hit, meaning that `SqlCacheDependencies.aspx` is now showing stale data.</span></span> <span data-ttu-id="0f6bb-298">如果不命中断点，则很可能因为数据的更改轮询服务不尚未激发。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-298">If the breakpoint is not hit, it is likely because the polling service has not yet fired since the data was changed.</span></span> <span data-ttu-id="0f6bb-299">请记住，轮询服务正在检查的更改`Products`表每个`pollTime`毫秒，而没有更新基础数据时和时逐出缓存的数据之间的延迟。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-299">Remember that the polling service is checking for changes to the `Products` table every `pollTime` milliseconds, so there is a delay between when the underlying data is updated and when the cached data is evicted.</span></span>

> [!NOTE]
> <span data-ttu-id="0f6bb-300">此延迟是更有可能出现在编辑通过在 GridView 的产品之一时`SqlCacheDependencies.aspx`。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-300">This delay is more likely to appear when editing one of the products through the GridView in `SqlCacheDependencies.aspx`.</span></span> <span data-ttu-id="0f6bb-301">在[体系结构中缓存数据](caching-data-in-the-architecture-vb.md)教程，我们添加`MasterCacheKeyArray`缓存依赖关系，以确保通过正在编辑的数据`ProductsCL`类的`UpdateProduct`方法已从缓存中逐出。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-301">In the [Caching Data in the Architecture](caching-data-in-the-architecture-vb.md) tutorial we added the `MasterCacheKeyArray` cache dependency to ensure that the data being edited through the `ProductsCL` class s `UpdateProduct` method was evicted from the cache.</span></span> <span data-ttu-id="0f6bb-302">但是，我们替换为此缓存依赖项时修改`AddCacheItem`之前在此步骤中的方法，因此`ProductsCL`类将继续显示缓存的数据，直到轮询系统会注意到更改`Products`表。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-302">However, we replaced this cache dependency when modifying the `AddCacheItem` method earlier in this step and therefore the `ProductsCL` class will continue to show the cached data until the polling system notes the change to the `Products` table.</span></span> <span data-ttu-id="0f6bb-303">我们将了解如何将重新引入`MasterCacheKeyArray`缓存在步骤 7 中的依赖项。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-303">We'll see how to reintroduce the `MasterCacheKeyArray` cache dependency in Step 7.</span></span>


## <a name="step-7-associating-multiple-dependencies-with-a-cached-item"></a><span data-ttu-id="0f6bb-304">步骤 7： 将多个依赖项与缓存的项相关联</span><span class="sxs-lookup"><span data-stu-id="0f6bb-304">Step 7: Associating Multiple Dependencies with a Cached Item</span></span>

<span data-ttu-id="0f6bb-305">回想一下，`MasterCacheKeyArray`缓存依赖项用于确保*所有*更新中其关联任何单个项时，与产品相关的数据从缓存中逐出。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-305">Recall that the `MasterCacheKeyArray` cache dependency is used to ensure that *all* product-related data is evicted from the cache when any single item associated within it is updated.</span></span> <span data-ttu-id="0f6bb-306">例如，`GetProductsByCategoryID(categoryID)`方法缓存`ProductsDataTables`实例为每个唯一*categoryID*值。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-306">For example, the `GetProductsByCategoryID(categoryID)` method caches `ProductsDataTables` instances for each unique *categoryID* value.</span></span> <span data-ttu-id="0f6bb-307">如果逐出这些对象之一，`MasterCacheKeyArray`缓存依赖项可确保其他还会删除。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-307">If one of these objects is evicted, the `MasterCacheKeyArray` cache dependency ensures that the others are also removed.</span></span> <span data-ttu-id="0f6bb-308">而无需此缓存依赖项，修改缓存的数据时可能性是存在的其他缓存的产品数据可能会过期。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-308">Without this cache dependency, when the cached data is modified the possibility exists that other cached product data may be out of date.</span></span> <span data-ttu-id="0f6bb-309">因此，它 s 重要我们维护`MasterCacheKeyArray`缓存时使用 SQL 缓存依赖项的依赖项。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-309">Consequently, it s important that we maintain the `MasterCacheKeyArray` cache dependency when using SQL cache dependencies.</span></span> <span data-ttu-id="0f6bb-310">但是，数据缓存 s`Insert`方法仅允许单个的依赖对象。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-310">However, the data cache s `Insert` method only allows for a single dependency object.</span></span>

<span data-ttu-id="0f6bb-311">此外，使用 SQL 缓存依赖项时我们可能需要将关联作为依赖关系的多个数据库表。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-311">Furthermore, when working with SQL cache dependencies we may need to associate multiple database tables as dependencies.</span></span> <span data-ttu-id="0f6bb-312">例如，`ProductsDataTable`缓存在中`ProductsCL`类包含每个产品类别和供应商名称但`AddCacheItem`方法仅使用一个依赖项上`Products`。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-312">For example, the `ProductsDataTable` cached in the `ProductsCL` class contains the category and supplier names for each product, but the `AddCacheItem` method only uses a dependency on `Products`.</span></span> <span data-ttu-id="0f6bb-313">在此情况下，如果用户更新的类别或供应商的名称缓存的产品数据将保留在缓存中并已过期。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-313">In this situation, if the user updates the name of a category or supplier, the cached product data will remain in the cache and be out of date.</span></span> <span data-ttu-id="0f6bb-314">因此，我们想要依赖于缓存的产品数据不仅`Products`表，但在`Categories`和`Suppliers`以及表。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-314">Therefore, we want to make the cached product data dependent on not only the `Products` table, but on the `Categories` and `Suppliers` tables as well.</span></span>

<span data-ttu-id="0f6bb-315">[ `AggregateCacheDependency`类](https://msdn.microsoft.com/en-us/library/system.web.caching.aggregatecachedependency.aspx)提供了一种将多个依赖项与缓存项相关联。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-315">The [`AggregateCacheDependency` class](https://msdn.microsoft.com/en-us/library/system.web.caching.aggregatecachedependency.aspx) provides a means for associating multiple dependencies with a cache item.</span></span> <span data-ttu-id="0f6bb-316">首先创建`AggregateCacheDependency`实例。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-316">Start by creating an `AggregateCacheDependency` instance.</span></span> <span data-ttu-id="0f6bb-317">接下来，添加一组的依赖关系使用`AggregateCacheDependency`s`Add`方法。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-317">Next, add the set of dependencies using the `AggregateCacheDependency` s `Add` method.</span></span> <span data-ttu-id="0f6bb-318">如果将项插入数据缓存之后，将传递中`AggregateCacheDependency`实例。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-318">When inserting the item into the data cache thereafter, pass in the `AggregateCacheDependency` instance.</span></span> <span data-ttu-id="0f6bb-319">当*任何*的`AggregateCacheDependency`实例 s 依赖项更改，将逐出缓存的项。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-319">When *any* of the `AggregateCacheDependency` instance s dependencies change, the cached item will be evicted.</span></span>

<span data-ttu-id="0f6bb-320">下面显示的更新的代码`ProductsCL`类的`AddCacheItem`方法。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-320">The following shows the updated code for the `ProductsCL` class s `AddCacheItem` method.</span></span> <span data-ttu-id="0f6bb-321">该方法将创建`MasterCacheKeyArray`缓存依赖项以及`SqlCacheDependency`对象`Products`， `Categories`，和`Suppliers`表。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-321">The method creates the `MasterCacheKeyArray` cache dependency along with `SqlCacheDependency` objects for the `Products`, `Categories`, and `Suppliers` tables.</span></span> <span data-ttu-id="0f6bb-322">这些所有合并成一个`AggregateCacheDependency`对象名为`aggregateDependencies`，后者再传递到`Insert`方法。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-322">These are all combined into one `AggregateCacheDependency` object named `aggregateDependencies`, which is then passed into the `Insert` method.</span></span>


[!code-vb[Main](using-sql-cache-dependencies-vb/samples/sample15.vb)]

<span data-ttu-id="0f6bb-323">测试出此新代码。现在将更改为`Products`， `Categories`，或`Suppliers`表导致被逐出缓存的数据。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-323">Test this new code out. Now changes to the `Products`, `Categories`, or `Suppliers` tables cause the cached data to be evicted.</span></span> <span data-ttu-id="0f6bb-324">此外，`ProductsCL`类 s`UpdateProduct`方法，它在编辑通过 GridView 产品时调用，逐出`MasterCacheKeyArray`缓存依赖项，这会导致缓存`ProductsDataTable`逐出和要在下次重新检索的数据请求。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-324">Moreover, the `ProductsCL` class s `UpdateProduct` method, which is called when editing a product through the GridView, evicts the `MasterCacheKeyArray` cache dependency, which causes the cached `ProductsDataTable` to be evicted and the data to be re-retrieved on the next request.</span></span>

> [!NOTE]
> <span data-ttu-id="0f6bb-325">SQL 缓存依赖项也可以用于[输出缓存](https://quickstarts.asp.net/QuickStartv20/aspnet/doc/caching/output.aspx)。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-325">SQL cache dependencies can also be used with [output caching](https://quickstarts.asp.net/QuickStartv20/aspnet/doc/caching/output.aspx).</span></span> <span data-ttu-id="0f6bb-326">此功能的演示，请参阅：[使用与 SQL Server ASP.NET 输出缓存](https://msdn.microsoft.com/en-us/library/e3w8402y(VS.80).aspx)。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-326">For a demonstration of this functionality, see: [Using ASP.NET Output Caching with SQL Server](https://msdn.microsoft.com/en-us/library/e3w8402y(VS.80).aspx).</span></span>


## <a name="summary"></a><span data-ttu-id="0f6bb-327">摘要</span><span class="sxs-lookup"><span data-stu-id="0f6bb-327">Summary</span></span>

<span data-ttu-id="0f6bb-328">除非在数据库中修改，否则，当缓存数据库的数据，数据将理想情况下会保留在缓存中。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-328">When caching database data, the data will ideally remain in the cache until it is modified in the database.</span></span> <span data-ttu-id="0f6bb-329">使用 ASP.NET 2.0 中，可以创建和声明性和编程方案中使用 SQL 缓存依赖项。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-329">With ASP.NET 2.0, SQL cache dependencies can be created and used in both declarative and programmatic scenarios.</span></span> <span data-ttu-id="0f6bb-330">使用此方法时面临的挑战之一是在发现时修改的数据。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-330">One of the challenges with this approach is in discovering when the data has been modified.</span></span> <span data-ttu-id="0f6bb-331">Microsoft SQL Server 2005 的完整版本提供当查询结果已更改时，可以通知应用程序的通知功能。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-331">The full versions of Microsoft SQL Server 2005 provide notification capabilities that can alert an application when a query result has changed.</span></span> <span data-ttu-id="0f6bb-332">对于 Express 版本的 SQL Server 2005 和 SQL server 的较旧版本，必须使用一种轮询系统。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-332">For the Express Edition of SQL Server 2005 and older versions of SQL Server, a polling system must be used instead.</span></span> <span data-ttu-id="0f6bb-333">幸运的是，设置必要的轮询基础结构将非常简单。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-333">Fortunately, setting up the necessary polling infrastructure is fairly straightforward.</span></span>

<span data-ttu-id="0f6bb-334">尽情享受编程 ！</span><span class="sxs-lookup"><span data-stu-id="0f6bb-334">Happy Programming!</span></span>

## <a name="further-reading"></a><span data-ttu-id="0f6bb-335">其他阅读材料</span><span class="sxs-lookup"><span data-stu-id="0f6bb-335">Further Reading</span></span>

<span data-ttu-id="0f6bb-336">在本教程中讨论的主题的详细信息，请参阅以下资源：</span><span class="sxs-lookup"><span data-stu-id="0f6bb-336">For more information on the topics discussed in this tutorial, refer to the following resources:</span></span>

- [<span data-ttu-id="0f6bb-337">在 Microsoft SQL Server 2005 中使用查询通知</span><span class="sxs-lookup"><span data-stu-id="0f6bb-337">Using Query Notifications in Microsoft SQL Server 2005</span></span>](https://msdn.microsoft.com/en-us/library/ms175110.aspx)
- [<span data-ttu-id="0f6bb-338">创建查询通知</span><span class="sxs-lookup"><span data-stu-id="0f6bb-338">Creating a Query Notification</span></span>](https://msdn.microsoft.com/en-us/library/ms188669.aspx)
- <span data-ttu-id="0f6bb-339">[在缓存中使用的 ASP.NET`SqlCacheDependency`类](https://msdn.microsoft.com/en-us/library/ms178604(VS.80).aspx)</span><span class="sxs-lookup"><span data-stu-id="0f6bb-339">[Caching in ASP.NET with the `SqlCacheDependency` Class](https://msdn.microsoft.com/en-us/library/ms178604(VS.80).aspx)</span></span>
- <span data-ttu-id="0f6bb-340">[ASP.NET SQL 服务器注册工具 (`aspnet_regsql.exe`)](https://msdn.microsoft.com/en-us/library/ms229862(vs.80).aspx)</span><span class="sxs-lookup"><span data-stu-id="0f6bb-340">[ASP.NET SQL Server Registration Tool (`aspnet_regsql.exe`)](https://msdn.microsoft.com/en-us/library/ms229862(vs.80).aspx)</span></span>
- [<span data-ttu-id="0f6bb-341">概述`SqlCacheDependency`</span><span class="sxs-lookup"><span data-stu-id="0f6bb-341">Overview of `SqlCacheDependency`</span></span>](http://www.aspnetresources.com/blog/sql_cache_depedency_overview.aspx)

## <a name="about-the-author"></a><span data-ttu-id="0f6bb-342">关于作者</span><span class="sxs-lookup"><span data-stu-id="0f6bb-342">About the Author</span></span>

<span data-ttu-id="0f6bb-343">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，作者的七个 ASP/ASP.NET 书籍和的创始人[4GuysFromRolla.com](http://www.4guysfromrolla.com)，自 1998 年使用与 Microsoft Web 技术。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-343">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="0f6bb-344">Scott 的作用是作为独立的顾问、 培训师和编写器。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-344">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="0f6bb-345">最新书籍是[ *Sam 教授自己 ASP.NET 2.0 24 小时内*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-345">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="0f6bb-346">他可以达到在[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)或通过他的博客，其中可以找到在[http://ScottOnWriting.NET](http://ScottOnWriting.NET)。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-346">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="0f6bb-347">特别感谢</span><span class="sxs-lookup"><span data-stu-id="0f6bb-347">Special Thanks To</span></span>

<span data-ttu-id="0f6bb-348">本教程系列已由许多有用的审阅者评审。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-348">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="0f6bb-349">本教程中的前导审阅者已 Marko Rangel、 Teresa 墨和希尔顿 Giesenow。</span><span class="sxs-lookup"><span data-stu-id="0f6bb-349">Lead reviewers for this tutorial were Marko Rangel, Teresa Murphy, and Hilton Giesenow.</span></span> <span data-ttu-id="0f6bb-350">对感兴趣查看我即将到来的 MSDN 文章？</span><span class="sxs-lookup"><span data-stu-id="0f6bb-350">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="0f6bb-351">如果是这样，删除我一行[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="0f6bb-351">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

>[!div class="step-by-step"]
[<span data-ttu-id="0f6bb-352">上一篇</span><span class="sxs-lookup"><span data-stu-id="0f6bb-352">Previous</span></span>](caching-data-at-application-startup-vb.md)
