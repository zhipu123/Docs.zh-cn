---
uid: aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/distributed-caching
title: "分布式缓存 （使用 Azure 构建真实世界云应用） |Microsoft 文档"
author: MikeWasson
description: "构建真实世界云应用程序与 Azure 的电子书基于由 Scott Guthrie 的演示。 它还说明了 13 模式和实践，他可以..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 07/20/2015
ms.topic: article
ms.assetid: 406518e9-3817-49ce-8b90-e82bc461e2c0
ms.technology: 
ms.prod: .net-framework
msc.legacyurl: /aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/distributed-caching
msc.type: authoredcontent
ms.openlocfilehash: 923a8257376e98e6cae10d905f1cb18f7fdb28e7
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/10/2017
---
<a name="distributed-caching-building-real-world-cloud-apps-with-azure"></a><span data-ttu-id="a18a5-104">分布式缓存 （构建真实世界云应用程序与 Azure）</span><span class="sxs-lookup"><span data-stu-id="a18a5-104">Distributed Caching (Building Real-World Cloud Apps with Azure)</span></span>
====================
<span data-ttu-id="a18a5-105">通过[Mike Wasson](https://github.com/MikeWasson)， [Rick Anderson](https://github.com/Rick-Anderson)， [Tom Dykstra](https://github.com/tdykstra)</span><span class="sxs-lookup"><span data-stu-id="a18a5-105">by [Mike Wasson](https://github.com/MikeWasson), [Rick Anderson](https://github.com/Rick-Anderson), [Tom Dykstra](https://github.com/tdykstra)</span></span>

<span data-ttu-id="a18a5-106">[下载修复此错误项目](http://code.msdn.microsoft.com/Fix-It-app-for-Building-cdd80df4)或[下载电子书](http://blogs.msdn.com/b/microsoft_press/archive/2014/07/23/free-ebook-building-cloud-apps-with-microsoft-azure.aspx)</span><span class="sxs-lookup"><span data-stu-id="a18a5-106">[Download Fix It Project](http://code.msdn.microsoft.com/Fix-It-app-for-Building-cdd80df4) or [Download E-book](http://blogs.msdn.com/b/microsoft_press/archive/2014/07/23/free-ebook-building-cloud-apps-with-microsoft-azure.aspx)</span></span>

> <span data-ttu-id="a18a5-107">**构建真实世界云应用程序与 Azure**电子书基于由 Scott Guthrie 的演示。</span><span class="sxs-lookup"><span data-stu-id="a18a5-107">The **Building Real World Cloud Apps with Azure** e-book is based on a presentation developed by Scott Guthrie.</span></span> <span data-ttu-id="a18a5-108">它还说明了 13 模式和实践，从而帮助你为成功开发适用于云中的 web 应用。</span><span class="sxs-lookup"><span data-stu-id="a18a5-108">It explains 13 patterns and practices that can help you be successful developing web apps for the cloud.</span></span> <span data-ttu-id="a18a5-109">有关电子书的信息，请参阅[第一章](introduction.md)。</span><span class="sxs-lookup"><span data-stu-id="a18a5-109">For information about the e-book, see [the first chapter](introduction.md).</span></span>


<span data-ttu-id="a18a5-110">前一章讨论过暂时性故障处理和提及缓存作为断路器策略。</span><span class="sxs-lookup"><span data-stu-id="a18a5-110">The previous chapter looked at transient fault handling and mentioned caching as a circuit breaker strategy.</span></span> <span data-ttu-id="a18a5-111">本章提供更多背景信息有关缓存，包括何时使用它，使用它的常见模式以及如何在 Azure 中实现它。</span><span class="sxs-lookup"><span data-stu-id="a18a5-111">This chapter gives more background about caching, including when to use it, common patterns for using it, and how to implement it in Azure.</span></span>

## <a name="what-is-distributed-caching"></a><span data-ttu-id="a18a5-112">什么被分布式缓存</span><span class="sxs-lookup"><span data-stu-id="a18a5-112">What is distributed caching</span></span>

<span data-ttu-id="a18a5-113">缓存提供高吞吐量、 低延迟访问通常访问的应用程序数据，通过将数据存储在内存中。</span><span class="sxs-lookup"><span data-stu-id="a18a5-113">A cache provides high throughput, low-latency access to commonly accessed application data, by storing the data in memory.</span></span> <span data-ttu-id="a18a5-114">对于云应用程序的最有用的一种缓存是分布式的缓存，这意味着在单独的 web 服务器的内存而是在其他云资源，不会存储数据，缓存的数据可供所有应用程序的 web 服务器 （或其他云 Vm 该 are 由应用程序的)。</span><span class="sxs-lookup"><span data-stu-id="a18a5-114">For a cloud app the most useful type of cache is distributed cache, which means the data is not stored on the individual web server's memory but on other cloud resources, and the cached data is made available to all of an application's web servers (or other cloud VMs that are used by the application).</span></span>

![显示访问相同的缓存服务器的多个 web 服务器的图示](distributed-caching/_static/image1.png)

<span data-ttu-id="a18a5-116">当应用程序扩展通过添加或删除服务器，或者服务器替换由于升级或故障，缓存的数据仍然可供运行该应用程序的每个服务器访问。</span><span class="sxs-lookup"><span data-stu-id="a18a5-116">When the application scales by adding or removing servers, or when servers are replaced due to upgrades or faults, the cached data remains accessible to every server that runs the application.</span></span>

<span data-ttu-id="a18a5-117">通过避免永久性数据存储的高延迟数据访问权限，缓存可以显著提高应用程序响应能力。</span><span class="sxs-lookup"><span data-stu-id="a18a5-117">By avoiding the high latency data access of a persistent data store, caching can dramatically improve application responsiveness.</span></span> <span data-ttu-id="a18a5-118">例如，从缓存中检索数据是比从关系数据库检索快得多。</span><span class="sxs-lookup"><span data-stu-id="a18a5-118">For example, retrieving data from cache is much faster than retrieving it from a relational database.</span></span>

<span data-ttu-id="a18a5-119">缓存的一个连带好处减少为永久性数据存储到永久性数据存储，这有数据流出量时，可能会导致降低成本的流量收费。</span><span class="sxs-lookup"><span data-stu-id="a18a5-119">A side benefit of caching is reduced traffic to the persistent data store, which may result in lower costs when there are data egress charges for the persistent data store.</span></span>

## <a name="when-to-use-distributed-caching"></a><span data-ttu-id="a18a5-120">何时使用分布式缓存</span><span class="sxs-lookup"><span data-stu-id="a18a5-120">When to use distributed caching</span></span>

<span data-ttu-id="a18a5-121">最适合应用程序工作负荷执行多个读取比写入数据，以及当数据模型支持用于存储和检索缓存中的数据的键/值组织的缓存工作方式。</span><span class="sxs-lookup"><span data-stu-id="a18a5-121">Caching works best for application workloads that do more reading than writing of data, and when the data model supports the key/value organization that you use to store and retrieve data in cache.</span></span> <span data-ttu-id="a18a5-122">它也是更有用时应用程序用户共享大量的常见数据;例如，缓存就无法提供尽可能多的好处，如果每个用户通常检索该用户所特有的数据。</span><span class="sxs-lookup"><span data-stu-id="a18a5-122">It's also more useful when application users share a lot of common data; for example, cache would not provide as many benefits if each user typically retrieves data unique to that user.</span></span> <span data-ttu-id="a18a5-123">缓存可能会非常有用的一个示例是产品目录，因为数据不经常，更改和所有客户正在都寻求通过相同的数据。</span><span class="sxs-lookup"><span data-stu-id="a18a5-123">An example where caching could be very beneficial is a product catalog, because the data does not change frequently, and all customers are looking at the same data.</span></span>

<span data-ttu-id="a18a5-124">缓存的好处将成为越来越多地显著提高应用程序的比例越多，随着的吞吐量限制和延迟延迟的持久数据存储多个应用程序总体性能方面的限制。</span><span class="sxs-lookup"><span data-stu-id="a18a5-124">The benefit of caching becomes increasingly measurable the more an application scales, as the throughput limits and latency delays of the persistent data store become more of a limit on overall application performance.</span></span> <span data-ttu-id="a18a5-125">但是，您可能会实现缓存性能也比其他原因。</span><span class="sxs-lookup"><span data-stu-id="a18a5-125">However, you might implement caching for other reasons than performance as well.</span></span> <span data-ttu-id="a18a5-126">对于不一定是完全最新时向用户显示的数据，缓存访问可以充当断路器为永久性数据存储时停止响应或不可用。</span><span class="sxs-lookup"><span data-stu-id="a18a5-126">For data that doesn't have to be perfectly up-to-date when shown to the user, cache access can serve as a circuit breaker for when the persistent data store is unresponsive or unavailable.</span></span>

## <a name="popular-cache-population-strategies"></a><span data-ttu-id="a18a5-127">常用缓存填充策略</span><span class="sxs-lookup"><span data-stu-id="a18a5-127">Popular cache population strategies</span></span>

<span data-ttu-id="a18a5-128">为了能够从缓存中检索数据，必须将其第一次存储存在。</span><span class="sxs-lookup"><span data-stu-id="a18a5-128">In order to be able to retrieve data from cache, you have to store it there first.</span></span> <span data-ttu-id="a18a5-129">有几种策略到缓存中获取所需的数据：</span><span class="sxs-lookup"><span data-stu-id="a18a5-129">There are several strategies for getting data that you need into a cache:</span></span>

- <span data-ttu-id="a18a5-130">按需 / 缓存端</span><span class="sxs-lookup"><span data-stu-id="a18a5-130">On Demand / Cache Aside</span></span>

    <span data-ttu-id="a18a5-131">应用程序尝试从缓存检索数据并时缓存不包含数据 ("miss")，应用程序存储数据在缓存中，以便它将提供的下一步的时间。</span><span class="sxs-lookup"><span data-stu-id="a18a5-131">The application tries to retrieve data from cache, and when the cache doesn't have the data (a "miss"), the application stores the data in the cache so that it will be available the next time.</span></span> <span data-ttu-id="a18a5-132">在尝试获取相同的数据，应用程序的下一步时它找到它寻找的内容在缓存中 （"命中"）。</span><span class="sxs-lookup"><span data-stu-id="a18a5-132">The next time the application tries to get the same data, it finds what it's looking for in the cache (a "hit").</span></span> <span data-ttu-id="a18a5-133">若要防止对数据库中提取已更改的缓存的数据，使在向数据存储区做出更改时失效缓存。</span><span class="sxs-lookup"><span data-stu-id="a18a5-133">To prevent fetching cached data that has changed on the database, you invalidate the cache when making changes to the data store.</span></span>
- <span data-ttu-id="a18a5-134">后台数据推送</span><span class="sxs-lookup"><span data-stu-id="a18a5-134">Background Data Push</span></span>

    <span data-ttu-id="a18a5-135">后台服务将数据推送到缓存定期计划，和应用程序始终将从缓存。</span><span class="sxs-lookup"><span data-stu-id="a18a5-135">Background services push data into the cache on a regular schedule, and the app always pulls from the cache.</span></span> <span data-ttu-id="a18a5-136">高延迟数据源，不需要您始终使用此方法适用出色返回最新数据。</span><span class="sxs-lookup"><span data-stu-id="a18a5-136">This approach works great with high latency data sources that don't require you always return the latest data.</span></span>
- <span data-ttu-id="a18a5-137">断路器</span><span class="sxs-lookup"><span data-stu-id="a18a5-137">Circuit Breaker</span></span>

    <span data-ttu-id="a18a5-138">应用程序通常将直接与通信永久性数据存储，但应用程序时永久性数据存储可用性问题，从缓存检索数据。</span><span class="sxs-lookup"><span data-stu-id="a18a5-138">The application normally communicates directly with the persistent data store, but when the persistent data store has availability problems, the application retrieves data from cache.</span></span> <span data-ttu-id="a18a5-139">可能会使用保留缓存或后台数据推送策略的缓存中使数据。</span><span class="sxs-lookup"><span data-stu-id="a18a5-139">Data may have been put in cache using either the cache aside or background data push strategy.</span></span> <span data-ttu-id="a18a5-140">这是错误处理策略，而不是性能增强策略。</span><span class="sxs-lookup"><span data-stu-id="a18a5-140">This is a fault handling strategy rather than a performance enhancing strategy.</span></span>

<span data-ttu-id="a18a5-141">为了使缓存中的数据当前，你可以删除相关的缓存条目，你的应用程序更新，创建或删除数据。</span><span class="sxs-lookup"><span data-stu-id="a18a5-141">In order to keep data in the cache current, you can delete related cache entries when your application creates, updates, or deletes data.</span></span> <span data-ttu-id="a18a5-142">如果它为你的应用程序有时会得到略有过期的数据是这样，你可以依赖于可配置的过期时间，以在多长缓存数据可以是上设置的限制。</span><span class="sxs-lookup"><span data-stu-id="a18a5-142">If it's alright for your application to sometimes get data that is slightly out-of-date, you can rely on a configurable expiration time to set a limit on how old cache data can be.</span></span>

<span data-ttu-id="a18a5-143">你可以配置绝对过期 （的缓存项创建以来的时间长度） 或滑动过期 （自上次访问缓存项后的时间量）。</span><span class="sxs-lookup"><span data-stu-id="a18a5-143">You can configure absolute expiration (amount of time since the cache item was created) or sliding expiration (amount of time since the last time a cache item was accessed).</span></span> <span data-ttu-id="a18a5-144">您有很大的缓存过期机制，以防止数据变得太陈旧上时，将使用绝对过期。</span><span class="sxs-lookup"><span data-stu-id="a18a5-144">Absolute expiration is used when you are depending on the cache expiration mechanism to prevent the data from becoming too stale.</span></span> <span data-ttu-id="a18a5-145">在修复它应用中，我们将手动将过期的缓存项和我们将使用滑动过期在缓存中保留最新数据。</span><span class="sxs-lookup"><span data-stu-id="a18a5-145">In the Fix It app, we'll manually evict stale cache items and we'll use sliding expiration to keep the most current data in cache.</span></span> <span data-ttu-id="a18a5-146">无论你选择的过期策略，缓存将自动逐出最旧的 （最近最少使用或 LRU） 项目，当达到缓存的内存限制。</span><span class="sxs-lookup"><span data-stu-id="a18a5-146">Regardless of the expiration policy you choose, the cache will automatically evict the oldest (Least Recently Used or LRU) items when the cache's memory limit is reached.</span></span>

## <a name="sample-cache-aside-code-for-fix-it-app"></a><span data-ttu-id="a18a5-147">修复它的应用的示例缓存端代码</span><span class="sxs-lookup"><span data-stu-id="a18a5-147">Sample cache-aside code for Fix It app</span></span>

<span data-ttu-id="a18a5-148">在下面的示例代码中，我们在缓存中检查第一次检索修复它任务时。</span><span class="sxs-lookup"><span data-stu-id="a18a5-148">In the following sample code, we check the cache first when retrieving a Fix It task.</span></span> <span data-ttu-id="a18a5-149">如果在缓存中找到该任务，我们将返回它;如果未找到，我们从数据库获取并将其存储在缓存中。</span><span class="sxs-lookup"><span data-stu-id="a18a5-149">If the task is found in cache, we return it; if not found, we get it from the database and store it in the cache.</span></span> <span data-ttu-id="a18a5-150">所做的更改将添加到缓存`FindTaskByIdAsync`方法将突出显示。</span><span class="sxs-lookup"><span data-stu-id="a18a5-150">The changes you'd make to add caching to the `FindTaskByIdAsync` method are highlighted.</span></span>

[!code-csharp[Main](distributed-caching/samples/sample1.cs?highlight=5,9-11,13-15,19)]

<span data-ttu-id="a18a5-151">当更新或删除修复它任务时，你必须使无效 （删除） 的已缓存任务。</span><span class="sxs-lookup"><span data-stu-id="a18a5-151">When you update or delete a Fix It task, you have to invalidate (remove) the cached task.</span></span> <span data-ttu-id="a18a5-152">否则，将来尝试读取该任务将继续从缓存中获取旧的数据。</span><span class="sxs-lookup"><span data-stu-id="a18a5-152">Otherwise, future attempts to read that task will continue to get the old data from the cache.</span></span>

[!code-csharp[Main](distributed-caching/samples/sample2.cs?highlight=7)]

<span data-ttu-id="a18a5-153">这些是示例来演示简单的缓存代码;缓存不实现了可下载修复它在项目中。</span><span class="sxs-lookup"><span data-stu-id="a18a5-153">These are samples to illustrate simple caching code; caching has not been implemented in the downloadable Fix It project.</span></span>

## <a name="azure-caching-services"></a><span data-ttu-id="a18a5-154">Azure 缓存服务</span><span class="sxs-lookup"><span data-stu-id="a18a5-154">Azure caching services</span></span>

<span data-ttu-id="a18a5-155">Azure 提供以下缓存服务： [Azure Redis 缓存](https://msdn.microsoft.com/en-us/library/dn690523.aspx)和[Azure 托管缓存](https://msdn.microsoft.com/en-us/library/dn386094.aspx)。</span><span class="sxs-lookup"><span data-stu-id="a18a5-155">Azure offers the following caching services: [Azure Redis Cache](https://msdn.microsoft.com/en-us/library/dn690523.aspx) and [Azure Managed Cache](https://msdn.microsoft.com/en-us/library/dn386094.aspx).</span></span> <span data-ttu-id="a18a5-156">Azure Redis 缓存基于流行[开放源代码 Redis 缓存](http://redis.io/)和大多数的第一个选择缓存方案。</span><span class="sxs-lookup"><span data-stu-id="a18a5-156">Azure Redis cache is based on the popular [open source Redis Cache](http://redis.io/) and is the first choice for most caching scenarios.</span></span>

<a id="sessionstate"></a>
## <a name="aspnet-session-state-using-a-cache-provider"></a><span data-ttu-id="a18a5-157">ASP.NET 会话状态使用缓存提供程序</span><span class="sxs-lookup"><span data-stu-id="a18a5-157">ASP.NET session state using a cache provider</span></span>

<span data-ttu-id="a18a5-158">中所述[web 开发最佳做法章](web-development-best-practices.md)，最佳做法是避免使用会话状态。</span><span class="sxs-lookup"><span data-stu-id="a18a5-158">As mentioned in the [web development best practices chapter](web-development-best-practices.md), a best practice is to avoid using session state.</span></span> <span data-ttu-id="a18a5-159">如果你的应用程序需要会话状态下, 一步的最佳做法是避免默认内存中提供程序，因为不支持横向扩展 （web 服务器的多个实例）。</span><span class="sxs-lookup"><span data-stu-id="a18a5-159">If your application requires session state, the next best practice is to avoid the default in-memory provider because that doesn't enable scale out (multiple instances of the web server).</span></span> <span data-ttu-id="a18a5-160">ASP.NET SQL Server 会话状态提供程序启用多个 web 服务器以使用会话状态, 运行的站点，但它会导致相比于内存中提供程序的高延迟成本。</span><span class="sxs-lookup"><span data-stu-id="a18a5-160">The ASP.NET SQL Server session state provider enables a site that runs on multiple web servers to use session state, but it incurs a high latency cost compared to an in-memory provider.</span></span> <span data-ttu-id="a18a5-161">如果你需要使用会话状态的最佳解决方案是使用缓存提供程序，如[用于 Azure Cache 的会话状态提供程序](https://msdn.microsoft.com/en-us/library/windowsazure/gg185668.aspx)。</span><span class="sxs-lookup"><span data-stu-id="a18a5-161">The best solution if you have to use session state is to use a cache provider, such as the [Session State Provider for Azure Cache](https://msdn.microsoft.com/en-us/library/windowsazure/gg185668.aspx).</span></span>

## <a name="summary"></a><span data-ttu-id="a18a5-162">摘要</span><span class="sxs-lookup"><span data-stu-id="a18a5-162">Summary</span></span>

<span data-ttu-id="a18a5-163">你已了解如何解决它应用可以实现缓存为了改进响应时间和可伸缩性，并使应用程序以继续数据库不可用时能够快地响应进行读取操作。</span><span class="sxs-lookup"><span data-stu-id="a18a5-163">You've seen how the Fix It app could implement caching in order to improve response time and scalability, and to enable the app to continue to be responsive for read operations when the database is unavailable.</span></span> <span data-ttu-id="a18a5-164">在[下一章](queue-centric-work-pattern.md)我们将演示如何以进一步提高可缩放性和使应用程序继续能够快地响应进行写入操作。</span><span class="sxs-lookup"><span data-stu-id="a18a5-164">In the [next chapter](queue-centric-work-pattern.md) we'll show how to further improve scalability and make the app continue to be responsive for write operations.</span></span>

## <a name="resources"></a><span data-ttu-id="a18a5-165">资源</span><span class="sxs-lookup"><span data-stu-id="a18a5-165">Resources</span></span>

<span data-ttu-id="a18a5-166">有关缓存的详细信息，请参阅以下资源。</span><span class="sxs-lookup"><span data-stu-id="a18a5-166">For more information about caching, see the following resources.</span></span>

<span data-ttu-id="a18a5-167">文档</span><span class="sxs-lookup"><span data-stu-id="a18a5-167">Documentation</span></span>

- <span data-ttu-id="a18a5-168">[Azure 缓存](https://msdn.microsoft.com/en-us/library/gg278356.aspx)。</span><span class="sxs-lookup"><span data-stu-id="a18a5-168">[Azure Cache](https://msdn.microsoft.com/en-us/library/gg278356.aspx).</span></span> <span data-ttu-id="a18a5-169">在 Azure 中的缓存上的正式 MSDN 文档。</span><span class="sxs-lookup"><span data-stu-id="a18a5-169">Official MSDN documentation on caching in Azure.</span></span>
- <span data-ttu-id="a18a5-170">[Microsoft 模式和实践-Azure 指南](https://msdn.microsoft.com/en-us/library/dn568099.aspx)。</span><span class="sxs-lookup"><span data-stu-id="a18a5-170">[Microsoft Patterns and Practices - Azure Guidance](https://msdn.microsoft.com/en-us/library/dn568099.aspx).</span></span> <span data-ttu-id="a18a5-171">请参阅缓存指南和缓存端模式。</span><span class="sxs-lookup"><span data-stu-id="a18a5-171">See Caching guidance and Cache-Aside pattern.</span></span>
- <span data-ttu-id="a18a5-172">[防故障： 弹性云体系结构指南](https://msdn.microsoft.com/en-us/library/windowsazure/jj853352.aspx)。</span><span class="sxs-lookup"><span data-stu-id="a18a5-172">[Failsafe: Guidance for Resilient Cloud Architectures](https://msdn.microsoft.com/en-us/library/windowsazure/jj853352.aspx).</span></span> <span data-ttu-id="a18a5-173">通过 Marc Mercuri、 Ulrich Homann 和 Andrew Townhill 白皮书。</span><span class="sxs-lookup"><span data-stu-id="a18a5-173">White paper by Marc Mercuri, Ulrich Homann, and Andrew Townhill.</span></span> <span data-ttu-id="a18a5-174">有关缓存，请参阅部分。</span><span class="sxs-lookup"><span data-stu-id="a18a5-174">See the section on Caching.</span></span>
- <span data-ttu-id="a18a5-175">[在 Azure 云服务上的大规模服务的设计的最佳实践](https://msdn.microsoft.com/en-us/library/windowsazure/jj717232.aspx)。</span><span class="sxs-lookup"><span data-stu-id="a18a5-175">[Best Practices for the Design of Large-Scale Services on Azure Cloud Services](https://msdn.microsoft.com/en-us/library/windowsazure/jj717232.aspx).</span></span> <span data-ttu-id="a18a5-176">W。</span><span class="sxs-lookup"><span data-stu-id="a18a5-176">W.</span></span> <span data-ttu-id="a18a5-177">Mark Simms 和 Michael Thomassy 白皮书。</span><span class="sxs-lookup"><span data-stu-id="a18a5-177">White paper by Mark Simms and Michael Thomassy.</span></span> <span data-ttu-id="a18a5-178">在分布式缓存，请参阅部分。</span><span class="sxs-lookup"><span data-stu-id="a18a5-178">See the section on distributed caching.</span></span>
- <span data-ttu-id="a18a5-179">[分布式缓存可伸缩性的路径](https://msdn.microsoft.com/en-us/magazine/dd942840.aspx)。</span><span class="sxs-lookup"><span data-stu-id="a18a5-179">[Distributed Caching On The Path To Scalability](https://msdn.microsoft.com/en-us/magazine/dd942840.aspx).</span></span> <span data-ttu-id="a18a5-180">较旧的 （2009 年） MSDN 杂志文章，但通常情况下; 分布式缓存的明确书面的介绍进入比防故障和最佳做法白皮书的缓存部分的更深入。</span><span class="sxs-lookup"><span data-stu-id="a18a5-180">An older (2009) MSDN Magazine article, but a clearly written introduction to distributed caching in general; goes into more depth than the caching sections of the FailSafe and Best Practices white papers.</span></span>

<span data-ttu-id="a18a5-181">视频</span><span class="sxs-lookup"><span data-stu-id="a18a5-181">Videos</span></span>

- <span data-ttu-id="a18a5-182">[防故障： 构建可扩展、 有弹性的云服务](https://channel9.msdn.com/Series/FailSafe)。</span><span class="sxs-lookup"><span data-stu-id="a18a5-182">[FailSafe: Building Scalable, Resilient Cloud Services](https://channel9.msdn.com/Series/FailSafe).</span></span> <span data-ttu-id="a18a5-183">包含 9 个部分组成的系列 Ulrich Homann、 Marc Mercuri 和 Mark Simms。</span><span class="sxs-lookup"><span data-stu-id="a18a5-183">Nine-part series by Ulrich Homann, Marc Mercuri, and Mark Simms.</span></span> <span data-ttu-id="a18a5-184">提供如何构建云应用程序的 400 级视图。</span><span class="sxs-lookup"><span data-stu-id="a18a5-184">Presents a 400-level view of how to architect cloud apps.</span></span> <span data-ttu-id="a18a5-185">这一系列主要关注理论和原因;有关更多操作指南的详细信息，请参阅 Mark Simms 构建大型系列。</span><span class="sxs-lookup"><span data-stu-id="a18a5-185">This series focuses on theory and reasons why; for more how-to details, see the Building Big series by Mark Simms.</span></span> <span data-ttu-id="a18a5-186">请参阅缓存中段 3 开始 1:24:14 讨论。</span><span class="sxs-lookup"><span data-stu-id="a18a5-186">See the caching discussion in episode 3 starting at 1:24:14.</span></span>
- <span data-ttu-id="a18a5-187">[构建大： 从 Azure 客户的第 I 部分到的经验教训](https://channel9.msdn.com/Events/Build/2012/3-029)。人 Simon Davies 讨论 46:00 处的分布式缓存开始。</span><span class="sxs-lookup"><span data-stu-id="a18a5-187">[Building Big: Lessons learned from Azure customers - Part I](https://channel9.msdn.com/Events/Build/2012/3-029). Simon Davies discusses distributed caching starting at 46:00.</span></span> <span data-ttu-id="a18a5-188">类似于防故障系列但进入更多操作指南的详细信息。</span><span class="sxs-lookup"><span data-stu-id="a18a5-188">Similar to the Failsafe series but goes into more how-to details.</span></span> <span data-ttu-id="a18a5-189">演示文稿提供 2012 年 10 月 31 日，因此它不涵盖在 2013年引入了的 Azure App Service Web apps 的缓存服务。</span><span class="sxs-lookup"><span data-stu-id="a18a5-189">The presentation was given October 31, 2012, so it does not cover caching service of Web Apps in Azure App Service that was introduced in 2013.</span></span>

<span data-ttu-id="a18a5-190">代码示例</span><span class="sxs-lookup"><span data-stu-id="a18a5-190">Code sample</span></span>

- <span data-ttu-id="a18a5-191">[云服务在 Azure 中的基础知识](https://code.msdn.microsoft.com/Cloud-Service-Fundamentals-4ca72649)。</span><span class="sxs-lookup"><span data-stu-id="a18a5-191">[Cloud Service Fundamentals in Azure](https://code.msdn.microsoft.com/Cloud-Service-Fundamentals-4ca72649).</span></span> <span data-ttu-id="a18a5-192">实现分布式缓存的示例应用程序。</span><span class="sxs-lookup"><span data-stu-id="a18a5-192">Sample application that implements distributed caching.</span></span> <span data-ttu-id="a18a5-193">请参阅随附的博客文章[云服务基础知识 – 缓存的基础知识](https://blogs.msdn.com/b/windowsazure/archive/2013/10/03/cloud-service-fundamentals-caching-basics.aspx)。</span><span class="sxs-lookup"><span data-stu-id="a18a5-193">See the accompanying blog post [Cloud Service Fundamentals – Caching Basics](https://blogs.msdn.com/b/windowsazure/archive/2013/10/03/cloud-service-fundamentals-caching-basics.aspx).</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="a18a5-194">[上一页](transient-fault-handling.md)
[下一页](queue-centric-work-pattern.md)</span><span class="sxs-lookup"><span data-stu-id="a18a5-194">[Previous](transient-fault-handling.md)
[Next](queue-centric-work-pattern.md)</span></span>
